---
title: "modeling terrestrial and arboreal mammals at GPNP"
author: "Gene Estrada"
date: "2024-05-21"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
	echo = FALSE,
	message = FALSE,
	warning = FALSE)

library(tidyverse)
library(vegan)
library(cowplot)
library(coefplot)
library(PerformanceAnalytics)
library(fitdistrplus)
library(MuMIn)
library(sjPlot)
library(factoextra)
library(ggpubr)
library(kableExtra)
library(FD)

#mammal observation data - excludes all human observations
m <- read.csv(file = "data/pruned.csv", header = TRUE)
m <- m[,-1]

#adding updated CT location forest type and partition data
ct <- read.csv(file = "data/CTlocations_partitions_May2024.csv", header = TRUE)

#removing lat, long, and habitat designations and adding updated versions
m <- m[,-c(12:14)]
m <- left_join(m, ct[,c("locationID","latitude","longitude","habitat","partition")], by = "locationID")

#ordering forest type
m$habitat <- factor(m$habitat, levels = c("Peat Swamp", "Freshwater Swamp", "Alluvial Bench", 
                                          "Lowland Sandstone", "Lowland Granite", "Upland Granite", "Montane"),
                    ordered = TRUE)
#ordering partitions
m$partition <- factor(m$partition, levels = c("PS1", "FS1", "AB1", "AB2",
                                          "LS1", "LS2","LG1","LG2", "UG1","UG2", "MO1", "MO2"),
                    ordered = TRUE)

#species observation summary table
#species_table <- as.data.frame(table(m$Species, m$habitat))
#species_table <- pivot_wider(species_table, names_from = "Var2", values_from = "Freq")
#colnames(species_table)[colnames(species_table) == 'Var1'] <- 'Species'
#write.csv(species_table, file = "species_observation_table_byFT.csv")

#LiDAR-derived metrics from {FORTLS} and {lidRmetrics}
stand_mets <- read.csv(file = "data/select.stand.mets.csv", header = TRUE)
stand_mets$habitat <- factor(stand_mets$habitat, levels = c("Peat Swamp", "Freshwater Swamp", "Alluvial Bench", 
                                          "Lowland Sandstone", "Lowland Granite", "Upland Granite", "Montane"),
                             ordered = TRUE)
stand_mets$partition <- factor(stand_mets$partition, levels = c("PS1", "FS1", "AB1", "AB2",
                                              "LS1", "LS2","LG1","LG2", "UG1","UG2", "MO1", "MO2"),
                      ordered = TRUE)

#all tree metrics
tree_mets <- read.csv(file = "data/all.tree.mets.csv", header = TRUE)
tree_mets$habitat <- factor(tree_mets$habitat, levels = c("Peat Swamp", "Freshwater Swamp", "Alluvial Bench", 
                                                            "Lowland Sandstone", "Lowland Granite",
                                                          "Upland Granite", "Montane"),
                            ordered = TRUE)
tree_mets$partition <- factor(tree_mets$partition, levels = c("PS1", "FS1", "AB1", "AB2",
                                                                "LS1", "LS2","LG1","LG2", "UG1","UG2", "MO1", "MO2"),
                               ordered = TRUE)
#camera trap metadata
ct_elev <- read.csv(file = "data/cameradata_updatedZJ-ajm.csv", header = TRUE)
ct_elev <- ct_elev[!duplicated(ct_elev$locationID),]

#add CT survey effort data
ct2 <- read.csv(file = "data/ofp_deployments-2021-11-04.csv", header = TRUE)
ct_active_days <- ct2 %>%
  dplyr::select(Deployment.Location.ID, Camera.Deployment.Begin.Date, Camera.Deployment.End.Date) %>%
  mutate(Camera.Deployment.Begin.Date = as.Date(Camera.Deployment.Begin.Date),
         Camera.Deployment.End.Date = as.Date(Camera.Deployment.End.Date)) %>%
  mutate(act.per = as.numeric(difftime(Camera.Deployment.End.Date, 
                                       Camera.Deployment.Begin.Date, units = "days"))) %>%
  group_by(Deployment.Location.ID) %>%
  summarise(act.days = sum(act.per)) %>%
  rename(locationID = Deployment.Location.ID)

stand_mets <- left_join(stand_mets, ct_active_days, by = "locationID") 

#adding PanTheria terrestriality data
traits <- read.csv(file = "data/mammal_list_ct_trait_202405.csv", header = TRUE)
m <- left_join(m, traits[,c("Species","Terrestriality")], by = "Species")

#read terrestrial mammal traits data
terr_traits <- read.csv(file = "data/mammal_traits_terr.csv", header = TRUE)
```

# I. Camera Trap Data

## SPECIES RICHNESS

### Entire Study Area

Excluding arboreal mammals, dogs, and taxa not identified to species level (Muntiacus spp., Tragulus spp. and Unid civets). All camera trap locations: 36 total species.

```{r}
#list of taxa not ID'd to species level, to exclude from some analyses
unid_taxa <- c("Canis familiaris", "Muntiacus spp.", "Tragulus spp.", "Unid civet")

#all camera trap locations
m %>%
  filter(Terrestriality == 1 &
         !Species %in% unid_taxa) %>%
  summarise(SpeciesRichness = n_distinct(Species))
```

Compared to only CT locations that have LiDAR data: 34 total species

```{r}
#only camera trap locations that have LiDAR scan data
m %>%
  filter(locationID %in% stand_mets$locationID & 
           Terrestriality == 1 &
         !Species %in% unid_taxa) %>%
  summarise(SpeciesRichness = n_distinct(Species))
```

### By forest type

Excluding arboreal mammals

```{r}
#all ct locations
n_by_ft <- m %>%
  group_by(habitat) %>%
  filter(Terrestriality == 1 &
         !Species %in% unid_taxa) %>%
  summarise(n.all = n_distinct(Species)) %>%
  arrange(desc(habitat))

#only scanned locations
n_by_ft <- m %>%
  filter(locationID %in% stand_mets$locationID) %>%
  group_by(habitat) %>%
  filter(Terrestriality == 1 &
         !Species %in% unid_taxa) %>%
  summarise(n.scanned = n_distinct(Species)) %>%
  left_join(n_by_ft) %>%
  arrange(desc(habitat))

#the scanned sites consistently observe fewer species over the study period by 4 - 10 species
#more bias in the higher elevation FT's, especially the montane
n_by_ft$diff <- n_by_ft$n.all - n_by_ft$n.scanned
n_by_ft
```

### By partition

Excluding unid animals

```{r}
#all ct locations
n_by_pt <- m %>%
  group_by(partition) %>%
  filter(Terrestriality == 1 &
         !Species %in% unid_taxa) %>%
  summarise(n.all = n_distinct(Species)) %>%
  arrange(desc(partition))

#only scanned locations
n_by_pt <- m %>%
  filter(locationID %in% stand_mets$locationID) %>%
  group_by(partition) %>%
  filter(Terrestriality == 1 &
         !Species %in% unid_taxa) %>%
  summarise(n.scanned = n_distinct(Species)) %>%
  left_join(n_by_pt) %>%
  arrange(desc(partition))

#the scanned sites consistently observe fewer species but this is especially true in UG1 and LS2
n_by_pt$diff <- n_by_pt$n.all - n_by_pt$n.scanned
n_by_pt

```

Again, but for terrestrial mammals only

```{r}
#filtering
m_filtered <- m %>%
  filter(Terrestriality == 1 &
         !Species %in% unid_taxa)

#by all partitions
ct_div_mets_terr <- m_filtered %>%
  group_by(partition) %>%
  summarise(n.terr = n_distinct(Species)) %>%
  arrange(desc(partition))

#by aggregated montane partition - combining MO1 and MO2 into one 'partition"
#ct_div_mets_terr_mod <- m_filtered %>%
 # mutate(partition = case_when(partition %in% c("MO1", "MO2") ~ "MO", TRUE ~ as.character(partition))) %>%
  #group_by(partition) %>%
  #summarise(n.terr = n_distinct(Species)) %>%
  #arrange(desc(partition))
```

### By camera trap location

Excluding arboreal mammals

```{r}
#all CT locations
n_by_ct <- m_filtered %>%
  group_by(locationID) %>%
  summarise(n.all = n_distinct(Species))

#compare 'all CT' and 'scanned CT' location richness distributions
#the 'scanned CT' locations seem biased towards higher species richness
hist(n_by_ct$n.all, breaks = 25,
     main = "species richness - all ct locations", xlab = "n species")
summary(n_by_ct$n.all)

hist(n_by_ct$n.all[n_by_ct$locationID %in% stand_mets$locationID], breaks = 20,
     main = "species richness - scanned ct locations only", xlab = "n species")
summary(n_by_ct$n.all[n_by_ct$locationID %in% stand_mets$locationID])
```

## SHANNON DIVERSITY

### By camera trap location

```{r}
shannon_ct <- diversity(table(m_filtered$locationID, m_filtered$Species), index = "shannon")
shannon_ct <- rownames_to_column(as.data.frame(shannon_ct), var = "locationID")
shannon_ct$locationID <- as.integer(shannon_ct$locationID)

#compare 'all CT' and 'scanned CT' location Shannon Diversity value distributions
#the 'scanned CT' locations seem only slightly biased towards higher diversity values
hist(shannon_ct$shannon_ct, breaks = 25, xlim = c(0,3),
     main = "species diversity - all ct locations", xlab = "Shannon Diversity Index")
summary(shannon_ct$shannon_ct)

hist(shannon_ct$shannon_ct[shannon_ct$locationID %in% stand_mets$locationID], breaks = 25, xlim = c(0,3),
     main = "species diversity - scanned ct locations only", xlab = "Shannon Diversity Index")
summary(shannon_ct$shannon_ct[shannon_ct$locationID %in% stand_mets$locationID])
```

### By partition

Comparing Shannon diversity aggregated at partition for all ct locations to only locations with LiDAR data

```{r}
shannon_all <- diversity(table(m_filtered$partition, m_filtered$Species), index = "shannon")
shannon_all <- rownames_to_column(as.data.frame(shannon_all), var = "partition")

shannon_scan <- diversity(table(m_filtered$partition[shannon_ct$locationID %in% stand_mets$locationID], 
                                m_filtered$Species[shannon_ct$locationID %in% stand_mets$locationID]), 
                          index = "shannon")

shannon_scan <- rownames_to_column(as.data.frame(shannon_scan), var = "partition")
shannon_pt <- left_join(shannon_all, shannon_scan)
rm(shannon_scan, shannon_all)

shannon_pt$diff <- shannon_pt$shannon_all - shannon_pt$shannon_scan
shannon_pt
```

Creating Shannon diversity metrics for terrestrial mammals only, for all partitions and partitions with montane aggregate

```{r}
### All partitions

#calculating Shannon diversity
shan_terr <- as.data.frame(diversity(table(m_filtered$partition, m_filtered$Species)))
colnames(shan_terr)[1] <- "Shannon"
shan_terr <- rownames_to_column(shan_terr, var = "partition")
ct_div_mets_terr <- left_join(ct_div_mets_terr, shan_terr, by = "partition")
rm(shan_terr)

#aggregated montane
#m_filtered_agg <- m_filtered %>%
 # mutate(partition = case_when(partition %in% c("MO1", "MO2") ~ "MO", TRUE ~ as.character(partition)))

#shan_terr <- as.data.frame(diversity(table(m_filtered_agg$partition, m_filtered_agg$Species)))
#colnames(shan_terr)[1] <- "Shannon"
#shan_terr <- rownames_to_column(shan_terr, var = "partition")
#ct_div_mets_terr_mod <- left_join(ct_div_mets_terr_mod, shan_terr, by = "partition")
#rm(shan_terr)
```

### By forest type

```{r}
#calculating shannon diversity index for all and scanned CT locations
shannon_all <- diversity(table(m_filtered$habitat, m_filtered$Species), index = "shannon")
shannon_all <- rownames_to_column(as.data.frame(shannon_all), var = "habitat")

shannon_scan <- diversity(table(m_filtered$habitat[shannon_ct$locationID %in% stand_mets$locationID],
                                m_filtered$Species[shannon_ct$locationID %in% stand_mets$locationID]), 
                          index = "shannon")

shannon_scan <- rownames_to_column(as.data.frame(shannon_scan), var = "habitat")
shannon_ft <- left_join(shannon_all, shannon_scan)
rm(shannon_scan, shannon_all)

#calculating difference between all and scanned locations shannon index
shannon_ft$diff <- shannon_ft$shannon_all - shannon_ft$shannon_scan
shannon_ft
```

## SPECIES EVENNESS

### By camera trap location

Pielou's diversity measure of species evenness

```{r}
div_mets <- shannon_ct %>%
  left_join(., n_by_ct) %>%
  mutate(div_even = shannon_ct/log(n.all))
div_mets$div_even[div_mets$div_even == "NaN"] <- 0

hist(div_mets$div_even, breaks = 25,
     main = "species evenness", xlab = "Pielou's Evenness Index")
```

### By partition

Pielou's diversity measure of species evenness

```{r}
ct_div_mets_terr$evenness <- ct_div_mets_terr$Shannon / log(ct_div_mets_terr$n.terr)

#not running for now since I don't need this modified montane partition 
#ct_div_mets_terr_mod$evenness <- ct_div_mets_terr_mod$Shannon / log(ct_div_mets_terr_mod$n.terr)
```

adding diversity metrics to forest structure metrics df

```{r}
stand_mets <- left_join(stand_mets, div_mets[,c("locationID","n.all","shannon_ct","div_even")], 
                        by = "locationID")
stand_mets$div_even <- as.numeric(stand_mets$div_even)
```


## FUNCTIONAL DIVERSITY METRICS

### By camera trap location

```{r}
#creating observation table
obs_table <- m %>%
  filter(Species %in% terr_traits$Species) %>%
  filter(!Species %in% c("Tragulus spp.","Unid civet","Unid Rat","Muntiacus spp.")) %>%
  group_by(locationID, Species) %>%
  summarise(n.ind = sum(Number.of.Animals)) %>%
  pivot_wider(names_from = Species, values_from = n.ind) %>%
  left_join(., ct_active_days) %>%
  mutate(across(-0, ~ . / act.days))

#placing columns in alphabetical order
species_columns <- sort(setdiff(names(obs_table), c("locationID", "act.days")))
obs_table <- obs_table %>% dplyr::select(locationID, all_of(species_columns))
obs_table <- as.data.frame(obs_table)

#setting locations as row names
rownames(obs_table) <- obs_table$locationID
obs_table <- obs_table[,-1]

#adjusting traits table
terr_traits_trim <- terr_traits[!terr_traits$Species %in% 
                                  c("Tragulus spp.","Unid civet",
                                    "Unid Rat","Muntiacus spp."),
                               -c(2,8,9)]

#setting species as row names
rownames(terr_traits_trim) <- terr_traits_trim$Species
terr_traits_trim <- terr_traits_trim[,-1]

#setting categorical vars as factors
terr_traits_trim$ActivityCycle <- as.factor(terr_traits_trim$ActivityCycle)
terr_traits_trim$TrophicLevel <- as.factor(terr_traits_trim$TrophicLevel)

#estimating functional diversity metrics
fd_metrics <- dbFD(terr_traits_trim, obs_table)

#fd metrics not calculated for CT locations with < 3 species (n = 12/172)
#table(is.na(fd_metrics$FRic))

#subset of metrics of interest
fd_metrics_df <- data.frame(
  locationID = as.integer(rownames(as.data.frame(fd_metrics$FRic))), 
  FRich = fd_metrics$FRic, 
  FEven = fd_metrics$FEve, 
  FDiver = fd_metrics$FDiv, 
  stringsAsFactors = FALSE)

#add to metrics table
stand_mets <- left_join(stand_mets, fd_metrics_df, by = "locationID")

#one scanned location is missing FD metric data: TL 26 S40, LG1
#stand_mets[is.na(stand_mets$FRich),]
```


### By partition

```{r}
#creating observation table by partition
obs_table_pt <- m %>%
  filter(Species %in% terr_traits$Species) %>%
  filter(!Species %in% c("Tragulus spp.","Unid civet","Unid Rat","Muntiacus spp.")) %>%
  group_by(partition, Species) %>%
  summarise(n.ind = sum(Number.of.Animals)) %>%
  pivot_wider(names_from = Species, values_from = n.ind)

#adding survey effort (n ct days)
ct_active_days <- left_join(ct_active_days, ct[,c("locationID", "habitat", "partition")])

obs_table_pt <- ct_active_days %>%
  group_by(partition) %>%
  summarise(act.days = sum(act.days)) %>%
  left_join(obs_table_pt, ., by = "partition")

#standardizing by survey effort and assigning partition to row names
obs_table_pt <- obs_table_pt %>% mutate(across(-0, ~ . / act.days))

obs_table_pt <- as.data.frame(obs_table_pt)
rownames(obs_table_pt) <- obs_table_pt$partition
obs_table_pt <- obs_table_pt[,-c(1, 37)]

#placing column names in alphabetical order
obs_table_pt <- obs_table_pt[, order(names(obs_table_pt))]

#calculating FD mets by partition
fd_metrics_pt <- dbFD(terr_traits_trim, obs_table_pt)

#subset of metrics of interest
fd_metrics_pt_df <- data.frame(
  partition = rownames(as.data.frame(fd_metrics_pt$FRic)), 
  FRich = fd_metrics_pt$FRic, 
  FEven = fd_metrics_pt$FEve, 
  FDiver = fd_metrics_pt$FDiv, 
  stringsAsFactors = FALSE)

#add to metrics table
ct_div_mets_terr <- left_join(ct_div_mets_terr, fd_metrics_pt_df, by = "partition")
```


#### Correlation between community metrics

By camera trap location:
```{r}
chart.Correlation(stand_mets[,c("n.all", "shannon_ct", "div_even", "FRich", "FEven", "FDiver")],
                  method = "spearman")
```

By partition:
```{r}
chart.Correlation(ct_div_mets_terr[,c("n.terr", "Shannon", "evenness", "FRich", "FEven", "FDiver")],
                  method = "spearman")
```



## COMMUNITY METRICS VISUALIZATION

```{r, include=FALSE}
#add habitat data to diversity metrics table
div_mets <- left_join(div_mets, ct[,c("locationID","habitat","partition","altitude")])
div_mets$habitat <- factor(div_mets$habitat, levels = c("Peat Swamp","Freshwater Swamp","Alluvial Bench",
                                                        "Lowland Sandstone","Lowland Granite",
                                                        "Upland Granite","Montane"))
#copying for visualization use only
div_mets$dataset <- "all"
div_mets$dataset[div_mets$locationID %in% stand_mets$locationID] <- "scanned"

div_mets_viz <- div_mets
div_mets_viz_scan <- div_mets_viz[div_mets_viz$dataset == "scanned",]
div_mets_viz$dataset <- "all"
div_mets_viz <- rbind(div_mets_viz, div_mets_viz_scan)
```

### Community metrics by CT location/forest type

```{r fig.height=4, fig.width=10}
#plotting richness by all and scanned locations in same plot 
cmp1 <- ggplot(div_mets_viz, aes(x = habitat, y = n.all, fill = dataset)) +
  geom_boxplot(position = position_dodge(width = 0.75), width = 0.5) +
  geom_jitter(position = position_dodge(width = 0.75)) +
  scale_fill_manual(values = c("cornflowerblue","coral3")) +
  theme_classic() +
  labs(title = "Species Richness", x = "", y = "n species", fill = "") +
  coord_flip() +
  theme(legend.position = "none", plot.title = element_text(hjust = 0.5))

#plotting diversity by all and scanned locations in same plot 
cmp2 <- ggplot(div_mets_viz, aes(x = habitat, y = shannon_ct, fill = dataset)) +
  geom_boxplot(position = position_dodge(width = 0.75), width = 0.5) +
  geom_jitter(position = position_dodge(width = 0.75)) +
  scale_fill_manual(values = c("cornflowerblue","coral3")) +
  theme_classic() +
  labs(title = "Shannon Diversity", x = "", y = "Shannon Diversity Index", fill = "") +
  coord_flip() +
  theme(legend.position = "none", axis.text.y = element_blank(), 
        plot.title = element_text(hjust = 0.5))

#plotting evenness by all and scanned locations in same plot 
cmp3 <- ggplot(div_mets_viz, aes(x = habitat, y = div_even, fill = dataset)) +
  geom_boxplot(position = position_dodge(width = 0.75), width = 0.5) +
  geom_jitter(position = position_dodge(width = 0.75)) +
  scale_fill_manual(values = c("cornflowerblue","coral3")) +
  theme_classic() +
  labs(title = "Species Evenness", x = "", y = "Evenness Index", fill = "") +
  coord_flip() +
  guides(fill = guide_legend(reverse = TRUE), color = guide_legend(reverse = TRUE)) +
  theme(legend.position = "none", axis.text.y = element_blank(), 
        plot.title = element_text(hjust = 0.5))

#cowplot::plot_grid(p1, p2, p3, nrow = 1, rel_widths = c(.4, .3, .3))
```


```{r fig.height=8, fig.width=10}
#add forest type/partition and elevation data to FD mets table
fd_metrics_df <- left_join(fd_metrics_df, ct[,c("locationID","habitat","partition")], by = "locationID")
fd_metrics_df$habitat <- factor(fd_metrics_df$habitat, 
                                levels = c("Peat Swamp","Freshwater Swamp","Alluvial Bench",
                                           "Lowland Sandstone", "Lowland Granite", "Upland Granite",
                                           "Montane"), ordered = TRUE)
fd_metrics_df <- left_join(fd_metrics_df, ct_elev[,c("locationID","altitude")])

fdp1 <- ggplot(fd_metrics_df, aes(x = habitat, y = FRich)) +
  geom_boxplot() +
  geom_jitter(position = position_dodge(width = 0.75)) +
  theme_classic() +
  labs(title = "Functional Richness", x = "", y = "F Rich") +
  coord_flip() +
  theme(plot.title = element_text(hjust = 0.5))

fdp2 <- ggplot(fd_metrics_df, aes(x = habitat, y = FEven)) +
  geom_boxplot() +
  geom_jitter(position = position_dodge(width = 0.75)) +
  theme_classic() +
  labs(title = "Functional Evenness", x = "", y = "F Even") +
  coord_flip() +
  theme(plot.title = element_text(hjust = 0.5),
         axis.text.y = element_blank())

fdp3 <- ggplot(fd_metrics_df, aes(x = habitat, y = FDiver)) +
  geom_boxplot() +
  geom_jitter(position = position_dodge(width = 0.75)) +
  theme_classic() +
  labs(title = "Functional Divergence", x = "", y = "F Diverg") +
  coord_flip() +
  theme(plot.title = element_text(hjust = 0.5),
         axis.text.y = element_blank())

cowplot::plot_grid(cmp1, cmp2, cmp3, fdp1, fdp3, fdp2, nrow = 2, rel_widths = c(.4, .3, .3))
```

### Community metrics by elevation

```{r fig.height=4, fig.width=10}
#species richness by elevation - 'all CT locations' and "scanned locations' in the same plot
p1 <- ggplot(div_mets, aes(x = altitude, y = n.all)) +
  geom_point(data = subset(div_mets, locationID %in% stand_mets$locationID), aes(color = "scanned")) +
  geom_point(data = subset(div_mets, !locationID %in% stand_mets$locationID), aes(color = "default")) +
  geom_smooth(data = subset(div_mets, locationID %in% stand_mets$locationID), aes(color = "scanned"), se = TRUE) +
  geom_smooth(data = div_mets, aes(color = "all"), se = TRUE) +  
  scale_color_manual(values = c("scanned" = "red", "all" = "blue", "default" = "black")) +  
  theme_classic() +
  theme(legend.position = "none", plot.title = element_text(hjust = 0.5)) + 
  labs(title = "Species Richness", x = "elevation (m)", y = "n species")

#shannon diversity by elevation
p2 <- ggplot(div_mets, aes(x = altitude, y = shannon_ct)) +
  geom_point(data = subset(div_mets, locationID %in% stand_mets$locationID), aes(color = "scanned")) +
  geom_point(data = subset(div_mets, !locationID %in% stand_mets$locationID), aes(color = "default")) +
  geom_smooth(data = subset(div_mets, locationID %in% stand_mets$locationID), aes(color = "scanned"), se = TRUE) +
  geom_smooth(data = div_mets, aes(color = "all"), se = TRUE) +  
  scale_color_manual(values = c("scanned" = "red", "all" = "blue", "default" = "black")) +  
  theme_classic() +
  theme(legend.position = "none", plot.title = element_text(hjust = 0.5)) + 
  labs(title = "Shannon Diversity", x = "elevation (m)", y = "Shannon Diversity Index")

#species evenness by elevation
p3 <- ggplot(div_mets, aes(x = altitude, y = div_even)) +
  geom_point(data = subset(div_mets, locationID %in% stand_mets$locationID), aes(color = "scanned")) +
  geom_point(data = subset(div_mets, !locationID %in% stand_mets$locationID), aes(color = "default")) +
  geom_smooth(data = subset(div_mets, locationID %in% stand_mets$locationID), aes(color = "scanned"), se = TRUE) +
  geom_smooth(data = div_mets, aes(color = "all"), se = TRUE) +  
  scale_color_manual(values = c("scanned" = "red", "all" = "blue", "default" = "black"),
                     name = NULL,
                     breaks = c("scanned", "all"),
                     labels = c("scanned locations", "all locations")) +  
  theme_classic() +
  theme(legend.position = c(.6, .2), plot.title = element_text(hjust = 0.5)) + 
  labs(title = "Species Evenness", x = "elevation (m)", y = "Species Evenness Index")

#functional richness
p4 <- ggplot(fd_metrics_df, aes(x = altitude, y = FRich)) +
  geom_point() +
  geom_smooth() +  
  theme_classic() +
  theme(legend.position = "none", plot.title = element_text(hjust = 0.5)) + 
  labs(title = "Functional Richness", x = "elevation (m)", y = "F Ric")

p5 <- ggplot(fd_metrics_df, aes(x = altitude, y = FEven)) +
  geom_point() +
  geom_smooth() +  
  theme_classic() +
  theme(legend.position = "none", plot.title = element_text(hjust = 0.5)) + 
  labs(title = "Functional Evenness", x = "elevation (m)", y = "F Eve")

p6 <- ggplot(fd_metrics_df, aes(x = altitude, y = FDiver)) +
  geom_point() +
  geom_smooth() +  
  theme_classic() +
  theme(legend.position = "none", plot.title = element_text(hjust = 0.5)) + 
  labs(title = "Functional Divergence", x = "elevation (m)", y = "F Diver")

cowplot::plot_grid(p1,p2,p3,p4,p6,p5, nrow = 2)
```


## MODELING - Terrestrial mammals (CT data)

```{r}
#scale and center numeric predictors
stand_mets <- stand_mets %>% mutate(across(c(5:16, 22:25, 27:29), scale, .names = "{.col}.sc"))
```

#### Descriptions of forest structure metrics used in models

I used {FORTLS} to extract the following metrics:

1.  max.height - maximum height of trees in the stand, in m

2.  mean.tree.h - mean tree height in the stand, in m.

3.  CRR.rho - canopy relief ratio, using rho for horizontal distance. A measure of canopy variation, with lower scores indicating lower local variation in canopy surface, i.e., more uniform age canopy/ less canopy surface complexity.

4.  sd.r - standard deviation of tree heights in stand in m. I've seen this value used as an approximation for vertical stratification.

5.  mean.dbh - mean diameter at breast height of trees in stand, in cm (measured at height of 1.3m)

6.  basal.area - basal area of trees in the stand (m2/ha)

7.  stand.dens - density of trees in the stand (trees/ha)

8.  stem.vol - volume of trees in the stand (m3/ha)

9.  pts.below.2m - shows the number of points in the point cloud that are below 2m.

I used {lidr} and {lidRmetrics} to extract the following metrics:

10. zentropy - normalized Shannon diversity index of z (height) values. Describes vertical complexity.

11. lad.max - Leaf Area Density maximum value for 1m vertical bins. Describes maximum foliage cover of the point cloud.

12. rumple - Rumple index (rugosity), a ratio of the canopy surface area to it's projected ground area.

vn - number of 1m voxels created for the following volumetric metrics.

13. vFRcanopy - ratio of filled to empty voxels, only counting cells within and below canopy, ignoring above.

14. vzrumple - vertical Rumple index.

15. ClosedGapSpace - volume of voxels that are classified as gaps underneath the canopy

#### Check correlation between predictors.

Basal area is highly correlated (\>0.8) with stem volume and stand density.

```{r}
chart.Correlation(stand_mets[,c("max.height.sc","sd.r.sc","CRR.rho.sc","pts.below.2m.sc","stand.dens.sc",
                                "basal.area.sc","stem.vol.sc","mean.tree.h.sc","mean.dbh.sc", "zentropy.sc",
                                "lad.max.sc","rumple.sc","vFRcanopy.sc","vzrumple.sc","ClosedGapSpace.sc")],
                  method = "spearman")
```

### Models by camera trap location
Fitting global model then using {dredge} to find models of best fit.
Restricting models to five predictors to avoid overfitting. Excluding two highly correlated pairs in dredge models: basal area & stand density, and basal area & stem volume.

#### Species richness model

```{r message=FALSE, warning=FALSE, include=FALSE}
#fitting global model for use in dredge
rm1 <- glm(n.all ~  
             max.height.sc +
             mean.tree.h.sc +
             CRR.rho.sc +
             sd.r.sc +
             mean.dbh.sc +
             basal.area.sc + 
             stand.dens.sc +
             stem.vol.sc +
             pts.below.2m.sc +
             zentropy.sc +
             lad.max.sc +
             rumple.sc +
             vFRcanopy.sc +
             vzrumple.sc +
             ClosedGapSpace.sc,
           na.action = na.fail,
           family = Gamma(link = "log"), 
           offset = log(act.days),
           data = stand_mets)
#dredge
rich_models <- dredge(rm1, m.max = 5, 
                      subset = !(basal.area.sc && stand.dens.sc) && 
                               !(basal.area.sc && stem.vol.sc))

#selecting top model by AIC
#top_rich_model <- get.models(rich_models, subset = 1)
#summary(top_rich_model[[1]])
```

averaged model output - averaging all models

```{r}
#averaging models
rich_models_avg <- model.avg(rich_models)
#summary(rich_models_avg)

plot(rich_models_avg, full = FALSE, intercept = FALSE, main = "Terrestrial Mammal Richness - Averaged Model")
```

#### Shannon diversity model

```{r message=FALSE, warning=FALSE}
#species diversity as outcome variable - by CT location
shannon_model <- glm(shannon_ct ~ 
                         max.height.sc +
                         mean.tree.h.sc +
                         CRR.rho.sc +
                         sd.r.sc +
                         mean.dbh.sc +
                         basal.area.sc +
                         stand.dens.sc +
                         stem.vol.sc +
                         pts.below.2m.sc +
                         zentropy.sc +
                         lad.max.sc +
                         rumple.sc +
                         vFRcanopy.sc +
                         vzrumple.sc +
                         ClosedGapSpace.sc,
                        na.action = na.fail,
                        family = Gamma(link = "log"), 
                        offset = log(act.days),
                        data = stand_mets)
#dredge
shan_models <- dredge(shannon_model, m.max = 5, 
                      subset = !(basal.area.sc && stand.dens.sc) && 
                               !(basal.area.sc && stem.vol.sc))

#selecting top model by AIC
#top_shan_model <- get.models(shan_models, subset = 1)
#summary(top_shan_model[[1]])
```

averaged model output - averaging all models

```{r}
#averaging models
shan_models_avg <- model.avg(shan_models)
#summary(shan_models_avg)

plot(shan_models_avg, full = FALSE, intercept = FALSE, main = "Terrestrial Mammal Diversity - Averaged Model")
```

#### Species evenness model

```{r message=FALSE, warning=FALSE, include=FALSE}
even_model <- glm(div_even ~ 
                max.height.sc +
                mean.tree.h.sc +
                CRR.rho.sc +
                sd.r.sc +
                mean.dbh.sc +
                basal.area.sc +
                stand.dens.sc +
                stem.vol.sc +
                pts.below.2m.sc +
                zentropy.sc +
                lad.max.sc +
                rumple.sc +
                vFRcanopy.sc +
                vzrumple.sc +
                ClosedGapSpace.sc,
                na.action = na.fail,
              family = Gamma(link = "log"), 
              offset = log(act.days),
              data = stand_mets)
#dredge
even_models <- dredge(even_model, m.max = 5, 
                      subset = !(basal.area.sc && stand.dens.sc) && 
                               !(basal.area.sc && stem.vol.sc))

#selecting top model by AIC
#top_even_model <- get.models(even_models, subset = 1)
#summary(top_even_model[[1]])
```

averaged model output - averaging all models

```{r}
#averaging all models
even_models_avg <- model.avg(even_models)
#summary(even_models_avg)

plot(even_models_avg, full = FALSE, intercept = FALSE, main = "Terrestrial Mammal Evenness - Avg. Model")
```

#### Functional richness model

Top model summary output

```{r message=FALSE, warning=FALSE, include=FALSE}
stand_mets_FD <- stand_mets[!is.na(stand_mets$FRich),]

frich_model <- glm(FRich ~ 
                max.height.sc +
                mean.tree.h.sc +
                CRR.rho.sc +
                sd.r.sc +
                mean.dbh.sc +
                basal.area.sc +
                stand.dens.sc +
                stem.vol.sc +
                pts.below.2m.sc +
                zentropy.sc +
                lad.max.sc +
                rumple.sc +
                vFRcanopy.sc +
                vzrumple.sc +
                ClosedGapSpace.sc,
                na.action = na.fail,
              family = Gamma(link = "log"), 
              offset = log(act.days),      
              data = stand_mets_FD)
#dredge
frich_models <- dredge(frich_model, m.max = 5, 
                      subset = !(basal.area.sc && stand.dens.sc) && 
                               !(basal.area.sc && stem.vol.sc))

#selecting top model by AIC
#top_frich_model <- get.models(frich_models, subset = 1)
#summary(top_frich_model[[1]])
```

averaged model output - averaging all models

```{r}
frich_models_avg <- model.avg(frich_models)
#summary(frich_models_avg)

plot(frich_models_avg, full = FALSE, intercept = FALSE, main = "Functional Richness - Avg. Model")
```

#### Functional evenness model

Top model summary output

```{r message=FALSE, warning=FALSE, include=FALSE}
feven_model <- glm(FEven ~ 
                max.height.sc +
                mean.tree.h.sc +
                CRR.rho.sc +
                sd.r.sc +
                mean.dbh.sc +
                basal.area.sc +
                stand.dens.sc +
                stem.vol.sc +
                pts.below.2m.sc +
                zentropy.sc +
                lad.max.sc +
                rumple.sc +
                vFRcanopy.sc +
                vzrumple.sc +
                ClosedGapSpace.sc,
                na.action = na.fail,
              family = Gamma(link = "log"), 
              offset = log(act.days),
              data = stand_mets_FD)
#dredge
feven_models <- dredge(feven_model, m.max = 5, 
                      subset = !(basal.area.sc && stand.dens.sc) && 
                               !(basal.area.sc && stem.vol.sc))

#selecting top model by AIC
#top_feven_model <- get.models(feven_models, subset = 1)
#summary(top_feven_model[[1]])
```

averaged model output - averaging all models

```{r message=FALSE, warning=FALSE, include=FALSE}
feven_models_avg <- model.avg(feven_models)
summary(feven_models_avg)
```

```{r}
plot(feven_models_avg, full = FALSE, intercept = FALSE, main = "Functional Evenness - Avg. Model")
```


#### Functional divergence model

Top model summary output

```{r message=FALSE, warning=FALSE, include=FALSE}
fdiver_model <- glm(FDiver ~ 
                max.height.sc +
                mean.tree.h.sc +
                CRR.rho.sc +
                sd.r.sc +
                mean.dbh.sc +
                basal.area.sc +
                stand.dens.sc +
                stem.vol.sc +
                pts.below.2m.sc +
                zentropy.sc +
                lad.max.sc +
                rumple.sc +
                vFRcanopy.sc +
                vzrumple.sc +
                ClosedGapSpace.sc,
                na.action = na.fail,
              family = Gamma(link = "log"), 
              offset = log(act.days),
              data = stand_mets_FD)
#dredge
fdiver_models <- dredge(fdiver_model, m.max = 5, 
                      subset = !(basal.area.sc && stand.dens.sc) && 
                               !(basal.area.sc && stem.vol.sc))

#selecting top model by AIC
#top_fdiver_model <- get.models(fdiver_models, subset = 1)
#summary(top_fdiver_model[[1]])
```

averaged model output - averaging all models

```{r message=FALSE, warning=FALSE, include=FALSE}
fdiver_models_avg <- model.avg(fdiver_models)
summary(fdiver_models_avg)
```

```{r}
plot(fdiver_models_avg, full = FALSE, intercept = FALSE, main = "Functional Divergence - Avg. Model")
```


#### Comparing coefficient plot from averaged models

Plotting variables from all models that are reliable predictors only (95% CI's don't overlap zero). No reliable predictors in the Shannon Diversity or Functional Richness models. However, in the Shannon model, stand density (neg) and zentropy (pos) were near reliable (CI's only slightly overlap 0). In the F Rich model this is true for vFRcanopy only (pos), similar to the richness model output. 

```{r}
#function to extract coefficients and confidence intervals
extract_coefs <- function(model_avg, model_name) {
  coefs <- as.data.frame(confint(model_avg))
  coefs$predictor <- rownames(coefs)
  coefs$estimate <- coef(model_avg)
  coefs$model <- model_name
  confint50 <- confint(model_avg, level = 0.5)
  coefs$`25 %` <- confint50[, 1]
  coefs$`75 %` <- confint50[, 2]
  return(coefs)
}

#extract coefficients for each averaged model
coef_rich <- extract_coefs(rich_models_avg, "rich")
coef_shan <- extract_coefs(shan_models_avg, "shan")
coef_even <- extract_coefs(even_models_avg, "even")
coef_fric <- extract_coefs(frich_models_avg, "fric")
coef_feve <- extract_coefs(feven_models_avg, "feve")
coef_fdiv <- extract_coefs(fdiver_models_avg, "fdiv")

#combine all
coef_df <- rbind(coef_rich, coef_shan, coef_even, coef_fric, coef_feve, coef_fdiv)
rm(coef_rich, coef_shan, coef_even, coef_fric, coef_feve, coef_fdiv)

#specifying order to plot models
coef_df$model <- factor(coef_df$model, levels = rev(c("rich","shan","even","fric","feve","fdiv")))

#select only predictors with CI's that don't overlap zero
coef_df_filter <- coef_df[!(coef_df$`2.5 %` <= 0 & coef_df$`97.5 %` >= 0),]
coef_df_filter <- coef_df_filter[coef_df_filter$predictor != "(Intercept)",]

#plotting
ggplot(coef_df_filter, aes(x = estimate, y = predictor, color = model)) +
  geom_point(position = position_dodge(width = 0.5), size = 3) +
  geom_errorbar(aes(xmin = `2.5 %`, xmax = `97.5 %`), width = 0, 
                position = position_dodge(width = 0.5)) +
  geom_errorbar(aes(xmin = `25 %`, xmax = `75 %`), width = 0, 
                position = position_dodge(width = 0.5), size = 1.5, linetype = "solid") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "grey50") +
  theme_classic() +
  labs(title = "Reliable Predictors from Averaged CT Models",
       x = "Coefficient Estimate", y = "") +
  theme(axis.text.y = element_text(hjust = 1),
        legend.position = "bottom") +
  guides(color = guide_legend(reverse = TRUE)) +
  scale_y_discrete(labels = c("vFRcanopy.sc" = "veg. vol.",
                              "stand.dens.sc" = "tree dens.",
                              "basal.area.sc" = "basal area"))

```


### MODELS BY PARTITION

```{r include=FALSE}
#calculating mean of all scaled predictors by partition
pt_mets <- stand_mets %>%
  group_by(partition) %>%
  dplyr::select(ends_with(".sc")) %>%
  summarize(across(where(is.numeric), mean, na.rm = TRUE))

ct_div_mets_terr <- left_join(ct_div_mets_terr, pt_mets)

#adding ct effort days
ct_div_mets_terr <- ct %>%
  left_join(ct_active_days) %>%
  group_by(partition) %>%
  summarise(effort = sum(act.days, na.rm = TRUE)) %>%
  filter(!partition == "Kerangas") %>%
  left_join(ct_div_mets_terr)
```

#### Check correlation between predictors.

Basal area is highly correlated (\>0.8) with stand density, max height with mean tree h and vzrumple, and vzrumple with mean tree height and rumple. 

```{r}
chart.Correlation(ct_div_mets_terr[,c("max.height.sc","sd.r.sc","CRR.rho.sc","pts.below.2m.sc",
                                    "stand.dens.sc","basal.area.sc","stem.vol.sc","mean.tree.h.sc",
                                    "mean.dbh.sc", "zentropy.sc","lad.max.sc","rumple.sc","vFRcanopy.sc",
                                    "vzrumple.sc","ClosedGapSpace.sc")],
                  method = "spearman")
```

#### Species richness model

Fitting global model then using {dredge} to find models of best fit.

Top model summary output. Restricting models to two predictors to avoid overfitting

```{r}
#removing MO1 partition since no structure mets are from this pt
ct_div_mets_terr <- ct_div_mets_terr[!ct_div_mets_terr$partition == "MO1",]
```

```{r message=FALSE, warning=FALSE, include=FALSE}
#fitting global model for use in dredge
rm_pt1 <- glm(n.terr ~ 
             max.height.sc +
             mean.tree.h.sc +
             CRR.rho.sc +
             sd.r.sc +
             mean.dbh.sc +
             basal.area.sc + 
             stand.dens.sc +
             stem.vol.sc +
             pts.below.2m.sc +
             zentropy.sc +
             lad.max.sc +
             rumple.sc +
             vFRcanopy.sc +
             vzrumple.sc +
             ClosedGapSpace.sc,
           na.action = na.fail,
           family = Gamma(link = "log"), 
           offset = log(effort),
           data = ct_div_mets_terr)

#dredge
rich_pt_models <- dredge(rm_pt1, m.max = 2, 
                      subset = !(basal.area.sc && stand.dens.sc) && 
                               !(basal.area.sc && stem.vol.sc) && 
                               !(max.height.sc && mean.tree.h.sc) && 
                               !(max.height.sc && vzrumple.sc) && 
                               !(mean.tree.h.sc && vzrumple.sc) && 
                               !(rumple.sc && vzrumple.sc))

#selecting top model by AIC
#top_rich_pt_model <- get.models(rich_pt_models, subset = 1)
#summary(top_rich_pt_model[[1]])
```

averaged model output - averaging all models

```{r message=FALSE, warning=FALSE, include=FALSE}
rich_models_pt_avg <- model.avg(rich_pt_models)
summary(rich_models_pt_avg)
```

```{r}
plot(rich_models_pt_avg, full = FALSE, intercept = FALSE, main = "Mammal Richness (partition) - Av. Mod")
```

#### Species diversity model

Top model summary output.

```{r message=FALSE, warning=FALSE, include=FALSE}
#global model
sm_pt1 <- glm(Shannon ~  
             max.height.sc +
             mean.tree.h.sc +
             CRR.rho.sc +
             sd.r.sc +
             mean.dbh.sc +
             basal.area.sc + 
             stand.dens.sc +
             stem.vol.sc +
             pts.below.2m.sc +
             zentropy.sc +
             lad.max.sc +
             rumple.sc +
             vFRcanopy.sc +
             vzrumple.sc +
             ClosedGapSpace.sc,
           na.action = na.fail,
           family = Gamma(link = "log"), 
           offset = log(effort),
           data = ct_div_mets_terr)
#dredge
shan_pt_models <- dredge(sm_pt1, m.max = 2, 
                      subset = !(basal.area.sc && stand.dens.sc) && 
                               !(basal.area.sc && stem.vol.sc) && 
                               !(max.height.sc && mean.tree.h.sc) && 
                               !(max.height.sc && vzrumple.sc) && 
                               !(mean.tree.h.sc && vzrumple.sc) && 
                               !(rumple.sc && vzrumple.sc))

#selecting top model by AIC
#top_shan_pt_model <- get.models(shan_pt_models, subset = 1)
#summary(top_shan_pt_model[[1]])
```

averaged model output - averaging all models

```{r message=FALSE, warning=FALSE, include=FALSE}
#averaging models
shan_models_pt_avg <- model.avg(shan_pt_models)
summary(shan_models_pt_avg)
```

```{r}
plot(shan_models_pt_avg, full = FALSE, intercept = FALSE, main = "Mammal Diversity (partition) - Av. Mod")
```

#### Species evenness model

Top model summary output.

```{r message=FALSE, warning=FALSE, include=FALSE}
#global model
em_pt1 <- glm(evenness ~  
             max.height.sc +
             mean.tree.h.sc +
             CRR.rho.sc +
             sd.r.sc +
             mean.dbh.sc +
             basal.area.sc + 
             stand.dens.sc +
             stem.vol.sc +
             pts.below.2m.sc +
             zentropy.sc +
             lad.max.sc +
             rumple.sc +
             vFRcanopy.sc +
             vzrumple.sc +
             ClosedGapSpace.sc,
           na.action = na.fail,
           family = Gamma(link = "log"), 
           offset = log(effort),
           data = ct_div_mets_terr)
#dredge
even_pt_models <- dredge(em_pt1, m.max = 2, 
                      subset = !(basal.area.sc && stand.dens.sc) && 
                               !(basal.area.sc && stem.vol.sc) && 
                               !(max.height.sc && mean.tree.h.sc) && 
                               !(max.height.sc && vzrumple.sc) && 
                               !(mean.tree.h.sc && vzrumple.sc) && 
                               !(rumple.sc && vzrumple.sc))

#selecting top model by AIC
#top_even_pt_model <- get.models(even_pt_models, subset = 1)
#summary(top_even_pt_model[[1]])
```

averaged model output - averaging all models

```{r message=FALSE, warning=FALSE, include=FALSE}
even_models_pt_avg <- model.avg(even_pt_models)
summary(even_models_pt_avg)
```

```{r}
plot(even_models_pt_avg, full = FALSE, intercept = FALSE, 
     main = "Terrestrial Mammal Evenness (partition) - Av. Mod")
```


#### Functional richness model

The model output here seems odd. After looking at the fric values closer, there seems to be an outlier here which may be throwing off the analysis. Not sure what to do here other than not include it in the final analysis, which may be warranted based on the high correlation between the richness and fric values (0.81)

```{r message=FALSE, warning=FALSE, include=FALSE}
#global model
frich_pt <- glm(FRich ~  
             max.height.sc +
             mean.tree.h.sc +
             CRR.rho.sc +
             sd.r.sc +
             mean.dbh.sc +
             basal.area.sc + 
             stand.dens.sc +
             stem.vol.sc +
             pts.below.2m.sc +
             zentropy.sc +
             lad.max.sc +
             rumple.sc +
             vFRcanopy.sc +
             vzrumple.sc +
             ClosedGapSpace.sc,
           na.action = na.fail,
           family = Gamma(link = "log"), 
           offset = log(effort),
           data = ct_div_mets_terr)
#dredge
frich_pt_models <- dredge(frich_pt, m.max = 2, 
                      subset = !(basal.area.sc && stand.dens.sc) && 
                               !(basal.area.sc && stem.vol.sc) && 
                               !(max.height.sc && mean.tree.h.sc) && 
                               !(max.height.sc && vzrumple.sc) && 
                               !(mean.tree.h.sc && vzrumple.sc) && 
                               !(rumple.sc && vzrumple.sc))

#selecting top model by AIC
#top_frich_pt_model <- get.models(frich_pt_models, subset = 1)
#summary(top_frich_pt_model[[1]])
```

averaged model output - averaging all models

```{r message=FALSE, warning=FALSE, include=FALSE}
frich_pt_models_avg <- model.avg(frich_pt_models)
summary(frich_pt_models_avg)
```

```{r}
plot(frich_pt_models_avg, full = FALSE, intercept = FALSE, 
     main = "Functional Richness (partition) - Av. Mod")
```


#### Functional evenness model

Top model summary output.

```{r message=FALSE, warning=FALSE, include=FALSE}
#global model
feven_pt <- glm(FEven ~  
             max.height.sc +
             mean.tree.h.sc +
             CRR.rho.sc +
             sd.r.sc +
             mean.dbh.sc +
             basal.area.sc + 
             stand.dens.sc +
             stem.vol.sc +
             pts.below.2m.sc +
             zentropy.sc +
             lad.max.sc +
             rumple.sc +
             vFRcanopy.sc +
             vzrumple.sc +
             ClosedGapSpace.sc,
           na.action = na.fail,
           family = Gamma(link = "log"), 
           offset = log(effort),
           data = ct_div_mets_terr)
#dredge
feven_pt_models <- dredge(feven_pt, m.max = 2, 
                      subset = !(basal.area.sc && stand.dens.sc) && 
                               !(basal.area.sc && stem.vol.sc) && 
                               !(max.height.sc && mean.tree.h.sc) && 
                               !(max.height.sc && vzrumple.sc) && 
                               !(mean.tree.h.sc && vzrumple.sc) && 
                               !(rumple.sc && vzrumple.sc))

#selecting top model by AIC
#top_feven_pt_model <- get.models(feven_pt_models, subset = 1)
#summary(top_feven_pt_model[[1]])
```

averaged model output - averaging all models

```{r message=FALSE, warning=FALSE, include=FALSE}
feven_pt_models_avg <- model.avg(feven_pt_models)
summary(feven_pt_models_avg)
```

```{r}
plot(feven_pt_models_avg, full = FALSE, intercept = FALSE, 
     main = "Functional Evenness (partition) - Av. Mod")
```


#### Functional divergence model

Top model summary output.

```{r message=FALSE, warning=FALSE, include=FALSE}
#global model
fdiver_pt <- glm(FDiver ~  
             max.height.sc +
             mean.tree.h.sc +
             CRR.rho.sc +
             sd.r.sc +
             mean.dbh.sc +
             basal.area.sc + 
             stand.dens.sc +
             stem.vol.sc +
             pts.below.2m.sc +
             zentropy.sc +
             lad.max.sc +
             rumple.sc +
             vFRcanopy.sc +
             vzrumple.sc +
             ClosedGapSpace.sc,
           na.action = na.fail,
           family = Gamma(link = "log"), 
           #offset = log(effort),
           data = ct_div_mets_terr)
#dredge
fdiver_pt_models <- dredge(fdiver_pt, m.max = 2, 
                      subset = !(basal.area.sc && stand.dens.sc) && 
                               !(basal.area.sc && stem.vol.sc) && 
                               !(max.height.sc && mean.tree.h.sc) && 
                               !(max.height.sc && vzrumple.sc) && 
                               !(mean.tree.h.sc && vzrumple.sc) && 
                               !(rumple.sc && vzrumple.sc))

#selecting top model by AIC
#top_fdiver_pt_model <- get.models(fdiver_pt_models, subset = 1)
#summary(top_fdiver_pt_model[[1]])
```

averaged model output - averaging all models

```{r message=FALSE, warning=FALSE, include=FALSE}
fdiver_pt_models_avg <- model.avg(fdiver_pt_models)
summary(fdiver_pt_models_avg)
```

```{r}
plot(fdiver_pt_models_avg, full = FALSE, intercept = FALSE, 
     main = "Functional Divergence (partition) - Av. Mod")
```


#### Comparing coefficient plot from averaged models, reliable predictors only

Since fric is highly correlated with richness (0.81) it makes sense to ignore this model here. Of the other models that have reliable predictors, the shannon and evenness values are also highly correlated (0.89) and both show vFRcanopy (vegetated volume) as the sole reliable predictor, so I also omit the evenness model here. 

```{r}
#extract coefficients for each averaged model
coef_rich <- extract_coefs(rich_models_pt_avg, "rich")
coef_shan <- extract_coefs(shan_models_pt_avg, "shan")
coef_even <- extract_coefs(even_models_pt_avg, "even")
coef_fric <- extract_coefs(frich_pt_models_avg, "fric")
coef_feve <- extract_coefs(feven_pt_models_avg, "feve")
coef_fdiv <- extract_coefs(fdiver_pt_models_avg, "fdiv")

#combine all
coef_pt_df <- rbind(coef_rich, coef_shan, coef_even, coef_fric, coef_feve, coef_fdiv)
rm(coef_rich, coef_shan, coef_even, coef_fric, coef_feve, coef_fdiv)

#specifying order to plot models
coef_pt_df$model <- factor(coef_pt_df$model, levels = rev(c("rich","shan","even","fric","feve","fdiv")))

#select only predictors with CI's that don't overlap zero
coef_pt_df_filter <- coef_pt_df[!(coef_pt_df$`2.5 %` <= 0 & coef_pt_df$`97.5 %` >= 0),]
coef_pt_df_filter <- coef_pt_df_filter[coef_pt_df_filter$predictor != "(Intercept)",]

#plotting
ggplot(coef_pt_df_filter[!coef_pt_df_filter$model %in% c("fric","even"),], 
       aes(x = estimate, y = predictor, color = model)) +
  geom_point(position = position_dodge(width = 0.5), size = 3) +
  geom_errorbar(aes(xmin = `2.5 %`, xmax = `97.5 %`), width = 0, 
                position = position_dodge(width = 0.5)) +
  geom_errorbar(aes(xmin = `25 %`, xmax = `75 %`), width = 0, 
                position = position_dodge(width = 0.5), size = 1.5, linetype = "solid") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "grey50") +
  theme_classic() +
  labs(title = "Reliable Predictors from Averaged Partition Models",
       x = "Coefficient Estimate", y = "") +
  theme(axis.text.y = element_text(hjust = 1),
        legend.position = "bottom") +
  guides(color = guide_legend(reverse = TRUE)) +
  scale_y_discrete(labels = c("vFRcanopy.sc" = "veg. vol.",
                              "rumple.sc" = "rumple index"))
```


## ORDINATION ANALYSIS

Using PCA to see how scan locations group together and to identify which forest structure metrics best differentiate between forest types and partitions.
```{r echo=FALSE, message=FALSE, warning=FALSE}
#run PCA
pca_result <- prcomp(stand_mets[,c("max.height",
                                   "sd.r",
                                   "CRR.rho",
                                   "pts.below.2m",
                                   "stand.dens",
                                   "basal.area",
                                   "stem.vol",
                                   "mean.tree.h",
                                   "mean.dbh",
                                   "zentropy",
                                   "lad.max",
                                   "rumple",
                                   "vFRcanopy",
                                   "vzrumple",
                                   "ClosedGapSpace")], 
                     scale. = TRUE)

#PCA scores
pca_scores <- as.data.frame(pca_result$x[, 1:2])
colnames(pca_scores) <- c("PC1", "PC2")

#add forest type and partition to pca_score table
pca_scores$ForestType <- stand_mets$habitat
pca_scores$partition <- stand_mets$partition

#calculate percentage of variance explained by each principal component
pca_var <- summary(pca_result)$importance[2, ]

#visualize eigenvalues (scree plot) - shows many dimensions explain much variance
fviz_eig(pca_result)

#plot PCA results with ellipses using ggplot2
ggplot(pca_scores, aes(x = PC1, y = PC2, color = as.factor(ForestType))) +
  geom_point(size = 3) +
  stat_ellipse(level = 0.95, aes(fill = as.factor(ForestType)), alpha = 0.2, geom = "polygon") +
  theme_classic() +
  labs(color = "Forest Type", fill = "Forest Type", title = "PCA of Forest Structure Metrics") +
  guides(color = guide_legend(reverse = TRUE), fill = guide_legend(reverse = TRUE))
```


Which structure metrics best differentiate between forest types?
```{r echo=FALSE, message=FALSE, warning=FALSE}
fviz_pca_var(pca_result,
             col.var = "contrib",
             gradient.cols = c("grey", "forestgreen", "black"),
             repel = TRUE)
```


## BIVARIATE PLOTS

### terrestrial mammals (ct data) by ct location

Structure metrics X species richness

```{r}
#selecting only metrics of interest
fs_mets <- c("max.height", "sd.r", "CRR.rho", "pts.below.2m", "stand.dens", "basal.area", "stem.vol", "mean.tree.h", "mean.dbh", "zentropy", "lad.max", "rumple", "vFRcanopy", "vzrumple", "ClosedGapSpace")

stand_mets %>%
  dplyr::select(location, n.all, shannon_ct, div_even, all_of(fs_mets)) %>%
  pivot_longer(cols = fs_mets, 
               names_to = "metric", 
               values_to = "value") %>%
  group_by(metric) %>%
  mutate(cor = cor(value, n.all, method = "spearman", use = "complete.obs"),
         subtitle = paste("Spearman's r =", round(cor, 2))) %>%
  ggplot(aes(x = value, y = n.all)) +
  geom_point() +
  geom_smooth(method = "gam", formula = y ~ s(x), se = FALSE, color = "cornflowerblue") +
  facet_wrap(~ metric, scales = "free_x") +
  labs(x = "Structure Metric Value", y = "Species Richness") +
  theme_minimal() +
  geom_text(data = . %>% group_by(metric) %>% summarise(cor = unique(cor)),
            aes(label = paste("Spearman's r =", round(cor, 2)), x = Inf, y = -Inf),
            hjust = 1.1, vjust = -1.1, color = "black", size = 3, 
            position = position_nudge(x = -0.5, y = 0.5))
```


Structure metrics X Shannon diversity

```{r}
stand_mets %>%
  dplyr::select(location, n.all, shannon_ct, div_even, all_of(fs_mets)) %>%
  pivot_longer(cols = all_of(fs_mets), 
               names_to = "metric", 
               values_to = "value") %>%
  group_by(metric) %>%
  mutate(cor = cor(value, shannon_ct, method = "spearman", use = "complete.obs"),
         subtitle = paste("Spearman's r =", round(cor, 2))) %>%
  ggplot(aes(x = value, y = shannon_ct)) +
  geom_point() +
  geom_smooth(method = "gam", formula = y ~ s(x), se = FALSE, color = "cornflowerblue") +
  facet_wrap(~ metric, scales = "free_x") +
  labs(x = "Structure Metric Value", y = "Shannon Diversity") +
  theme_minimal() +
  geom_text(data = . %>% group_by(metric) %>% summarise(cor = unique(cor)),
            aes(label = paste("Spearman's r =", round(cor, 2)), x = Inf, y = -Inf),
            hjust = 1.1, vjust = -1.1, color = "black", size = 3, 
            position = position_nudge(x = -0.5, y = 0.5))
```

Structure metrics X Species Evenness

```{r}
stand_mets %>%
  dplyr::select(location, n.all, shannon_ct, div_even, all_of(fs_mets)) %>%
  pivot_longer(cols = all_of(fs_mets), 
               names_to = "metric", 
               values_to = "value") %>%
  group_by(metric) %>%
  mutate(cor = cor(value, div_even, method = "spearman", use = "complete.obs"),
         subtitle = paste("Spearman's r =", round(cor, 2))) %>%
  ggplot(aes(x = value, y = div_even)) +
  geom_point() +
  geom_smooth(method = "gam", formula = y ~ s(x), se = FALSE, color = "cornflowerblue") +
  facet_wrap(~ metric, scales = "free_x") +
  labs(x = "Structure Metric Value", y = "Species Evenness") +
  theme_minimal() +
  geom_text(data = . %>% group_by(metric) %>% summarise(cor = unique(cor)),
            aes(label = paste("Spearman's r =", round(cor, 2)), x = Inf, y = -Inf),
            hjust = 1.1, vjust = -1.1, color = "black", size = 3, 
            position = position_nudge(x = -0.5, y = 0.5))
```

Structure metrics X Functional Richness

```{r}
stand_mets %>%
  dplyr::select(location, FRich, FEven, FDiver, all_of(fs_mets)) %>%
  pivot_longer(cols = all_of(fs_mets), 
               names_to = "metric", 
               values_to = "value") %>%
  group_by(metric) %>%
  mutate(cor = cor(value, FRich, method = "spearman", use = "complete.obs"),
         subtitle = paste("Spearman's r =", round(cor, 2))) %>%
  ggplot(aes(x = value, y = FRich)) +
  geom_point() +
  geom_smooth(method = "gam", formula = y ~ s(x), se = FALSE, color = "cornflowerblue") +
  facet_wrap(~ metric, scales = "free_x") +
  labs(x = "Structure Metric Value", y = "Functional Richness") +
  theme_minimal() +
  geom_text(data = . %>% group_by(metric) %>% summarise(cor = unique(cor)),
            aes(label = paste("Spearman's r =", round(cor, 2)), x = Inf, y = -Inf),
            hjust = 1.1, vjust = -1.1, color = "black", size = 3, 
            position = position_nudge(x = -0.5, y = 0.5))
```

Structure metrics X Functional Evenness

```{r}
stand_mets %>%
  dplyr::select(location, FRich, FEven, FDiver, all_of(fs_mets)) %>%
  pivot_longer(cols = all_of(fs_mets), 
               names_to = "metric", 
               values_to = "value") %>%
  group_by(metric) %>%
  mutate(cor = cor(value, FEven, method = "spearman", use = "complete.obs"),
         subtitle = paste("Spearman's r =", round(cor, 2))) %>%
  ggplot(aes(x = value, y = FEven)) +
  geom_point() +
  geom_smooth(method = "gam", formula = y ~ s(x), se = FALSE, color = "cornflowerblue") +
  facet_wrap(~ metric, scales = "free_x") +
  labs(x = "Structure Metric Value", y = "Functional Evenness") +
  theme_minimal() +
  geom_text(data = . %>% group_by(metric) %>% summarise(cor = unique(cor)),
            aes(label = paste("Spearman's r =", round(cor, 2)), x = Inf, y = -Inf),
            hjust = 1.1, vjust = -1.1, color = "black", size = 3, 
            position = position_nudge(x = -0.5, y = 0.5))
```

Structure metrics X Functional Divergence

```{r}
stand_mets %>%
  dplyr::select(location, FRich, FEven, FDiver, all_of(fs_mets)) %>%
  pivot_longer(cols = all_of(fs_mets), 
               names_to = "metric", 
               values_to = "value") %>%
  group_by(metric) %>%
  mutate(cor = cor(value, FDiver, method = "spearman", use = "complete.obs"),
         subtitle = paste("Spearman's r =", round(cor, 2))) %>%
  ggplot(aes(x = value, y = FDiver)) +
  geom_point() +
  geom_smooth(method = "gam", formula = y ~ s(x), se = FALSE, color = "cornflowerblue") +
  facet_wrap(~ metric, scales = "free_x") +
  labs(x = "Structure Metric Value", y = "Functional Divergence") +
  theme_minimal() +
  geom_text(data = . %>% group_by(metric) %>% summarise(cor = unique(cor)),
            aes(label = paste("Spearman's r =", round(cor, 2)), x = Inf, y = -Inf),
            hjust = 1.1, vjust = -1.1, color = "black", size = 3, 
            position = position_nudge(x = -0.5, y = 0.5))
```


### terrestrial mammals (ct data) by partition

Structure metrics X species richness

```{r}
ct_div_mets_terr %>%
  pivot_longer(cols = c(9:27), names_to = "metric", values_to = "value") %>%
  group_by(metric) %>%
  mutate(cor = cor(value, n.terr, method = "spearman", use = "complete.obs"),
         subtitle = paste("Spearman's r =", round(cor, 2))) %>%
  ggplot(aes(x = value, y = n.terr)) +
  geom_point() +
  geom_smooth(method = "gam", formula = y ~ s(x), se = FALSE, color = "cornflowerblue") +
  facet_wrap(~ metric, scales = "free_x") +
  labs(x = "Structure Metric Value", y = "Species Richness") +
  theme_minimal() +
  geom_text(data = . %>% group_by(metric) %>% summarise(cor = unique(cor)),
            aes(label = paste("Spearman's r =", round(cor, 2)), x = Inf, y = -Inf),
            hjust = 1.1, vjust = -1.1, color = "black", size = 3, 
            position = position_nudge(x = -0.5, y = 0.5))
```


Structure metrics X Shannon diversity

```{r}
ct_div_mets_terr %>%
  pivot_longer(cols = c(9:27), names_to = "metric", values_to = "value") %>%
  group_by(metric) %>%
  mutate(cor = cor(value, Shannon, method = "spearman", use = "complete.obs"),
         subtitle = paste("Spearman's r =", round(cor, 2))) %>%
  ggplot(aes(x = value, y = Shannon)) +
  geom_point() +
  geom_smooth(method = "gam", formula = y ~ s(x), se = FALSE, color = "cornflowerblue") +
  facet_wrap(~ metric, scales = "free_x") +
  labs(x = "Structure Metric Value", y = "Shannon Diversity") +
  theme_minimal() +
  geom_text(data = . %>% group_by(metric) %>% summarise(cor = unique(cor)),
            aes(label = paste("Spearman's r =", round(cor, 2)), x = Inf, y = -Inf),
            hjust = 1.1, vjust = -1.1, color = "black", size = 3, 
            position = position_nudge(x = -0.5, y = 0.5))
```

Structure metrics X Species Evenness

```{r}
ct_div_mets_terr %>%
  pivot_longer(cols = c(9:27), names_to = "metric", values_to = "value") %>%
  group_by(metric) %>%
  mutate(cor = cor(value, evenness, method = "spearman", use = "complete.obs"),
         subtitle = paste("Spearman's r =", round(cor, 2))) %>%
  ggplot(aes(x = value, y = evenness)) +
  geom_point() +
  geom_smooth(method = "gam", formula = y ~ s(x), se = FALSE, color = "cornflowerblue") +
  facet_wrap(~ metric, scales = "free_x") +
  labs(x = "Structure Metric Value", y = "Species Evenness") +
  theme_minimal() +
  geom_text(data = . %>% group_by(metric) %>% summarise(cor = unique(cor)),
            aes(label = paste("Spearman's r =", round(cor, 2)), x = Inf, y = -Inf),
            hjust = 1.1, vjust = -1.1, color = "black", size = 3, 
            position = position_nudge(x = -0.5, y = 0.5))
```


summary table for Pearson correlation between structure metrics and diversity metrics
```{r}
#creating matrix for vars at the CT scale
divmets <- c("n.all", "shannon_ct", "div_even", "FRich", "FEven", "FDiver")

cor_matrix <- matrix(nrow = length(fs_mets), ncol = length(divmets))
rownames(cor_matrix) <- fs_mets
colnames(cor_matrix) <- divmets

#calculate Pearson correlation coefficients
for (i in 1:length(fs_mets)) {
  for (j in 1:length(divmets)) {
    cor_matrix[i, j] <- cor(stand_mets[[fs_mets[i]]], stand_mets[[divmets[j]]], 
                            method = "pearson", use = "complete.obs")
  }
}

#creating matrix for vars at the partition scale
divmets <- c("n.terr", "Shannon", "evenness", "FRich", "FEven", "FDiver")

cor_matrix2 <- matrix(nrow = length(fs_mets), ncol = length(divmets))
rownames(cor_matrix2) <- paste0(fs_mets, ".sc")
colnames(cor_matrix2) <- divmets

#calculate Pearson correlation coefficients
for (i in 1:length(fs_mets)) {
  for (j in 1:length(divmets)) {
    cor_matrix2[i, j] <- cor(ct_div_mets_terr[[paste0(fs_mets, ".sc")[i]]], ct_div_mets_terr[[divmets[j]]], method = "pearson")
  }
}

#combining matrices and changing model names for clarity
cor_df <- as.data.frame(cbind(cor_matrix, cor_matrix2))
colnames(cor_df) <- c("Richness", "Shannon Diversity", "Evenness", 
                      "Func. Richness", "Func. Evenness", "Func. Divergence",
                      "Richness", "Shannon Diversity", "Evenness", 
                      "Func. Richness", "Func. Evenness", "Func. Divergence")

#create table
kbl(cor_df, format = "html", 
    caption = "Pearson correlations beteen structure metrics and diversity metrics") %>%
  kable_styling(bootstrap_options = "striped") %>%
  add_header_above(c(" " = 1, "Camera Trap Scale" = 6, "Partition Scale" = 6))
```

