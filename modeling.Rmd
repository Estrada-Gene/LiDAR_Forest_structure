---
title: "modeling terrestrial mammal diversity at GPNP"
author: "Gene Estrada"
date: "2024-05-21"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
	echo = FALSE,
	message = FALSE,
	warning = FALSE)

library(Hmisc)
library(tidyverse)
library(vegan)
library(cowplot)
library(coefplot)
library(PerformanceAnalytics)
library(fitdistrplus)
library(MuMIn)
library(sjPlot)
library(factoextra)
library(ggpubr)
library(kableExtra)
library(FD)
library(geosphere)
library(sp)
library(spdep)
library(sf)
library(spmoran)
library(corrplot)
library(ggeffects)

#mammal observation data - excludes all human observations
m <- read.csv(file = "data/pruned.csv", header = TRUE)
m <- m[,-1]

#camera trap location forest type and partition data
ct <- read.csv(file = "data/CTlocations_partitions_May2024.csv", header = TRUE)

#removing lat, long, and habitat designations and adding updated versions
m <- m[,-c(12:14)]
m <- left_join(m, ct[,c("locationID","latitude","longitude","habitat","partition")], by = "locationID")

#ordering forest type
m$habitat <- factor(m$habitat, levels = c("Peat Swamp", "Freshwater Swamp", "Alluvial Bench", 
                                          "Lowland Sandstone", "Lowland Granite", "Upland Granite", "Montane"),
                    ordered = TRUE)
#ordering partitions
m$partition <- factor(m$partition, levels = c("PS1", "FS1", "AB1", "AB2",
                                          "LS1", "LS2","LG1","LG2", "UG1","UG2", "MO1", "MO2"),
                    ordered = TRUE)

#LiDAR-derived metrics from {FORTLS} and {lidRmetrics}
stand_mets <- read.csv(file = "data/select.stand.mets.csv", header = TRUE)
stand_mets$habitat <- factor(stand_mets$habitat, levels = c("Peat Swamp", "Freshwater Swamp", "Alluvial Bench", 
                                          "Lowland Sandstone", "Lowland Granite", "Upland Granite", "Montane"),
                             ordered = TRUE)
stand_mets$partition <- factor(stand_mets$partition, levels = c("PS1", "FS1", "AB1", "AB2",
                                              "LS1", "LS2","LG1","LG2", "UG1","UG2", "MO1", "MO2"),
                      ordered = TRUE)

#all tree metrics
tree_mets <- read.csv(file = "data/all.tree.mets.csv", header = TRUE)
tree_mets$habitat <- factor(tree_mets$habitat, levels = c("Peat Swamp", "Freshwater Swamp", "Alluvial Bench", 
                                                            "Lowland Sandstone", "Lowland Granite",
                                                          "Upland Granite", "Montane"),
                            ordered = TRUE)
tree_mets$partition <- factor(tree_mets$partition, levels = c("PS1", "FS1", "AB1", "AB2",
                                                                "LS1", "LS2","LG1","LG2", "UG1","UG2", "MO1", "MO2"),
                               ordered = TRUE)
#camera trap metadata
ct_elev <- read.csv(file = "data/cameradata_updatedZJ-ajm.csv", header = TRUE)
ct_elev <- ct_elev[!duplicated(ct_elev$locationID),]

#add CT survey effort data
ct2 <- read.csv(file = "data/ofp_deployments-2021-11-04.csv", header = TRUE)
ct_active_days <- ct2 %>%
  dplyr::select(Deployment.Location.ID, Camera.Deployment.Begin.Date, Camera.Deployment.End.Date) %>%
  mutate(Camera.Deployment.Begin.Date = as.Date(Camera.Deployment.Begin.Date),
         Camera.Deployment.End.Date = as.Date(Camera.Deployment.End.Date)) %>%
  mutate(act.per = as.numeric(difftime(Camera.Deployment.End.Date, 
                                       Camera.Deployment.Begin.Date, units = "days"))) %>%
  group_by(Deployment.Location.ID) %>%
  summarise(act.days = sum(act.per)) %>%
  rename(locationID = Deployment.Location.ID)

stand_mets <- left_join(stand_mets, ct_active_days, by = "locationID") 

#adding PanTheria terrestriality data
traits <- read.csv(file = "data/mammal_list_ct_trait_202405.csv", header = TRUE)
m <- left_join(m, traits[,c("Species","Terrestriality")], by = "Species")

#read terrestrial mammal traits data
terr_traits <- read.csv(file = "data/mammal_traits_terr.csv", header = TRUE)
```

## SPECIES RICHNESS

### Entire Study Area

Excluding arboreal mammals, dogs, and taxa not identified to species level (Muntiacus spp., Tragulus spp. and Unid civets). All camera trap locations: 36 total species.

```{r}
#list of taxa not ID'd to species level, to exclude from some analyses
unid_taxa <- c("Canis familiaris", "Muntiacus spp.", "Tragulus spp.", "Unid civet")

#all camera trap locations
m %>%
  filter(Terrestriality == 1 &
         !Species %in% unid_taxa) %>%
  summarise(SpeciesRichness = n_distinct(Species))
```


### By forest type
```{r}
#all ct locations
#n_by_ft <- m %>%
 # group_by(habitat) %>%
  #filter(Terrestriality == 1 &
   #      !Species %in% unid_taxa) %>%
  #summarise(n.all = n_distinct(Species)) %>%
  #arrange(desc(habitat))
```

### By partition
```{r}
#all ct locations
#n_by_pt <- m %>%
 # group_by(partition) %>%
  #filter(Terrestriality == 1 &
   #      !Species %in% unid_taxa) %>%
  #summarise(n.all = n_distinct(Species)) %>%
  #arrange(desc(partition))
```

### By partition - terrestrial mammals only
```{r}
#selecting terrestrial mammals only, removing obs not identified to species
m_filtered <- m %>%
  filter(Terrestriality == 1 &
         !Species %in% unid_taxa)

#by all partitions
ct_div_mets_terr <- m_filtered %>%
  group_by(partition) %>%
  summarise(n.terr = n_distinct(Species)) %>%
  arrange(desc(partition))

#just using scanned CT locations for comparison ##################### cor is pretty low
m_filtered %>%
  filter(locationID %in% stand_mets$locationID) %>%
  group_by(partition) %>%
  summarise(n.terr.scan = n_distinct(Species)) %>%
  arrange(desc(partition)) %>%
  left_join(ct_div_mets_terr) %>%
  mutate(diff = n.terr - n.terr.scan) %>%
  { with(., cor(n.terr, n.terr.scan, method = "spearman")) }
```

### By camera trap location
```{r}
#all CT locations
n_by_ct <- m_filtered %>%
  group_by(locationID) %>%
  summarise(n.all = n_distinct(Species))
```

## SHANNON DIVERSITY

### By camera trap location
```{r}
shannon_ct <- diversity(table(m_filtered$locationID, m_filtered$Species), index = "shannon")
shannon_ct <- rownames_to_column(as.data.frame(shannon_ct), var = "locationID")
shannon_ct$locationID <- as.integer(shannon_ct$locationID)
```

### By partition

Comparing Shannon diversity aggregated at partition for all ct locations to only locations with LiDAR data

```{r}
shannon_all <- diversity(table(m_filtered$partition, m_filtered$Species), index = "shannon")
shannon_all <- rownames_to_column(as.data.frame(shannon_all), var = "partition")

shannon_scan <- diversity(table(m_filtered$partition[shannon_ct$locationID %in% stand_mets$locationID], 
                                m_filtered$Species[shannon_ct$locationID %in% stand_mets$locationID]), 
                          index = "shannon")

shannon_scan <- rownames_to_column(as.data.frame(shannon_scan), var = "partition")
shannon_pt <- left_join(shannon_all, shannon_scan)
rm(shannon_scan, shannon_all)

shannon_pt$diff <- shannon_pt$shannon_all - shannon_pt$shannon_scan
shannon_pt

#correlation between div mets using All vs Scanned sites
cor(shannon_pt$shannon_all, shannon_pt$shannon_scan, method = "pearson")  #0.96
cor(shannon_pt$shannon_all, shannon_pt$shannon_scan, method = "spearman") #0.94
```

Creating Shannon diversity metrics for terrestrial mammals only, for all partitions and partitions with montane aggregate

```{r}
### All partitions

#calculating Shannon diversity
shan_terr <- as.data.frame(diversity(table(m_filtered$partition, m_filtered$Species)))
colnames(shan_terr)[1] <- "Shannon"
shan_terr <- rownames_to_column(shan_terr, var = "partition")
ct_div_mets_terr <- left_join(ct_div_mets_terr, shan_terr, by = "partition")
rm(shan_terr)

#aggregated montane
#m_filtered_agg <- m_filtered %>%
 # mutate(partition = case_when(partition %in% c("MO1", "MO2") ~ "MO", TRUE ~ as.character(partition)))

#shan_terr <- as.data.frame(diversity(table(m_filtered_agg$partition, m_filtered_agg$Species)))
#colnames(shan_terr)[1] <- "Shannon"
#shan_terr <- rownames_to_column(shan_terr, var = "partition")
#ct_div_mets_terr_mod <- left_join(ct_div_mets_terr_mod, shan_terr, by = "partition")
#rm(shan_terr)
```

### By forest type

```{r}
#calculating shannon diversity index for all and scanned CT locations
shannon_all <- diversity(table(m_filtered$habitat, m_filtered$Species), index = "shannon")
shannon_all <- rownames_to_column(as.data.frame(shannon_all), var = "habitat")

shannon_scan <- diversity(table(m_filtered$habitat[shannon_ct$locationID %in% stand_mets$locationID],
                                m_filtered$Species[shannon_ct$locationID %in% stand_mets$locationID]), 
                          index = "shannon")

shannon_scan <- rownames_to_column(as.data.frame(shannon_scan), var = "habitat")
shannon_ft <- left_join(shannon_all, shannon_scan)
rm(shannon_scan, shannon_all)

#calculating difference between all and scanned locations shannon index
shannon_ft$diff <- shannon_ft$shannon_all - shannon_ft$shannon_scan
shannon_ft
```

## SPECIES EVENNESS

### By camera trap location

Pielou's diversity measure of species evenness

```{r}
div_mets <- shannon_ct %>%
  left_join(., n_by_ct) %>%
  mutate(div_even = shannon_ct/log(n.all))
div_mets$div_even[div_mets$div_even == "NaN"] <- 0

hist(div_mets$div_even, breaks = 25,
     main = "species evenness", xlab = "Pielou's Evenness Index")
```

### By partition

Pielou's diversity measure of species evenness

```{r}
ct_div_mets_terr$evenness <- ct_div_mets_terr$Shannon / log(ct_div_mets_terr$n.terr)

#not running for now since I don't need this modified montane partition 
#ct_div_mets_terr_mod$evenness <- ct_div_mets_terr_mod$Shannon / log(ct_div_mets_terr_mod$n.terr)
```

adding diversity metrics to forest structure metrics df

```{r}
stand_mets <- left_join(stand_mets, div_mets[,c("locationID","n.all","shannon_ct","div_even")], 
                        by = "locationID")
stand_mets$div_even <- as.numeric(stand_mets$div_even)
```


## FUNCTIONAL DIVERSITY METRICS

### By camera trap location

```{r}
#creating observation table
obs_table <- m %>%
  filter(Species %in% terr_traits$Species) %>%
  filter(!Species %in% c("Tragulus spp.","Unid civet","Unid Rat","Muntiacus spp.")) %>%
  group_by(locationID, Species) %>%
  summarise(n.ind = sum(Number.of.Animals)) %>%
  pivot_wider(names_from = Species, values_from = n.ind)
  #left_join(., ct_active_days) %>%
  #mutate(across(-0, ~ . / act.days))

#placing columns in alphabetical order
species_columns <- sort(setdiff(names(obs_table), c("locationID", "act.days")))
obs_table <- obs_table %>% dplyr::select(locationID, all_of(species_columns))
obs_table <- as.data.frame(obs_table)

#setting locations as row names
rownames(obs_table) <- obs_table$locationID
obs_table <- obs_table[,-1]

#adjusting traits table
terr_traits_trim <- terr_traits[!terr_traits$Species %in% 
                                  c("Tragulus spp.","Unid civet",
                                    "Unid Rat","Muntiacus spp."),
                               -c(2,8,9)]

#setting species as row names
rownames(terr_traits_trim) <- terr_traits_trim$Species
terr_traits_trim <- terr_traits_trim[,-1]

#setting categorical vars as factors
terr_traits_trim$ActivityCycle <- as.factor(terr_traits_trim$ActivityCycle)
terr_traits_trim$TrophicLevel <- as.factor(terr_traits_trim$TrophicLevel)

#estimating functional diversity metrics
fd_metrics <- dbFD(terr_traits_trim, obs_table)

#fd metrics not calculated for CT locations with < 3 species (n = 12/172)
#table(is.na(fd_metrics$FRic))

#subset of metrics of interest
fd_metrics_df <- data.frame(
  locationID = as.integer(rownames(as.data.frame(fd_metrics$FRic))), 
  FRich = fd_metrics$FRic, 
  FEven = fd_metrics$FEve, 
  FDiver = fd_metrics$FDiv, 
  stringsAsFactors = FALSE)

#add to metrics table
stand_mets <- left_join(stand_mets, fd_metrics_df, by = "locationID")

#one scanned location is missing FD metric data: TL 26 S40, LG1
#stand_mets[is.na(stand_mets$FRich),]
```


### By partition

```{r}
#creating observation table by partition
obs_table_pt <- m %>%
  filter(Species %in% terr_traits$Species) %>%
  filter(!Species %in% c("Tragulus spp.","Unid civet","Unid Rat","Muntiacus spp.")) %>%
  group_by(partition, Species) %>%
  summarise(n.ind = sum(Number.of.Animals)) %>%
  pivot_wider(names_from = Species, values_from = n.ind)

#adding survey effort (n ct days)
ct_active_days <- left_join(ct_active_days, ct[,c("locationID", "habitat", "partition")])

obs_table_pt <- ct_active_days %>%
  group_by(partition) %>%
  summarise(act.days = sum(act.days)) %>%
  left_join(obs_table_pt, ., by = "partition")

#standardizing by survey effort and assigning partition to row names
#obs_table_pt <- obs_table_pt %>% mutate(across(-0, ~ . / act.days))

obs_table_pt <- as.data.frame(obs_table_pt)
rownames(obs_table_pt) <- obs_table_pt$partition
obs_table_pt <- obs_table_pt[,-c(1, 37)]

#placing column names in alphabetical order
obs_table_pt <- obs_table_pt[, order(names(obs_table_pt))]

#calculating FD mets by partition
fd_metrics_pt <- dbFD(terr_traits_trim, obs_table_pt)

#subset of metrics of interest
fd_metrics_pt_df <- data.frame(
  partition = rownames(as.data.frame(fd_metrics_pt$FRic)), 
  FRich = fd_metrics_pt$FRic, 
  FEven = fd_metrics_pt$FEve, 
  FDiver = fd_metrics_pt$FDiv, 
  stringsAsFactors = FALSE)

#add to metrics table
ct_div_mets_terr <- left_join(ct_div_mets_terr, fd_metrics_pt_df, by = "partition")
```


## COMMUNITY METRICS VISUALIZATION

```{r, include=FALSE}
#add habitat data to diversity metrics table
div_mets <- left_join(div_mets, ct[,c("locationID","habitat","partition","altitude")])
div_mets$habitat <- factor(div_mets$habitat, levels = c("Peat Swamp","Freshwater Swamp","Alluvial Bench",
                                                        "Lowland Sandstone","Lowland Granite",
                                                        "Upland Granite","Montane"))
#copying for visualization use only
div_mets$dataset <- "all"
div_mets$dataset[div_mets$locationID %in% stand_mets$locationID] <- "scanned"

div_mets_viz <- div_mets
div_mets_viz_scan <- div_mets_viz[div_mets_viz$dataset == "scanned",]
div_mets_viz$dataset <- "all"
div_mets_viz <- rbind(div_mets_viz, div_mets_viz_scan)
```

### Community metrics by CT location/forest type

```{r eval=FALSE, fig.height=4, fig.width=10, include=FALSE}
#plotting richness by all and scanned locations in same plot 
cmp1 <- ggplot(div_mets_viz, aes(x = habitat, y = n.all, fill = dataset)) +
  geom_boxplot(position = position_dodge(width = 0.75), width = 0.5) +
  geom_jitter(position = position_dodge(width = 0.75)) +
  scale_fill_manual(values = c("cornflowerblue","coral3")) +
  theme_classic() +
  labs(title = "Species Richness", x = "", y = "n species", fill = "") +
  coord_flip() +
  theme(legend.position = "none", plot.title = element_text(hjust = 0.5))

#plotting diversity by all and scanned locations in same plot 
cmp2 <- ggplot(div_mets_viz, aes(x = habitat, y = shannon_ct, fill = dataset)) +
  geom_boxplot(position = position_dodge(width = 0.75), width = 0.5) +
  geom_jitter(position = position_dodge(width = 0.75)) +
  scale_fill_manual(values = c("cornflowerblue","coral3")) +
  theme_classic() +
  labs(title = "Shannon Diversity", x = "", y = "Shannon Diversity Index", fill = "") +
  coord_flip() +
  theme(legend.position = "none", axis.text.y = element_blank(), 
        plot.title = element_text(hjust = 0.5))

#plotting evenness by all and scanned locations in same plot 
cmp3 <- ggplot(div_mets_viz, aes(x = habitat, y = div_even, fill = dataset)) +
  geom_boxplot(position = position_dodge(width = 0.75), width = 0.5) +
  geom_jitter(position = position_dodge(width = 0.75)) +
  scale_fill_manual(values = c("cornflowerblue","coral3")) +
  theme_classic() +
  labs(title = "Species Evenness", x = "", y = "Evenness Index", fill = "") +
  coord_flip() +
  guides(fill = guide_legend(reverse = TRUE), color = guide_legend(reverse = TRUE)) +
  theme(legend.position = "none", axis.text.y = element_blank(), 
        plot.title = element_text(hjust = 0.5))

#cowplot::plot_grid(p1, p2, p3, nrow = 1, rel_widths = c(.4, .3, .3))
```


```{r fig.height=8, fig.width=10}
#add forest type/partition and elevation data to FD mets table
fd_metrics_df <- left_join(fd_metrics_df, ct[,c("locationID","habitat","partition")], by = "locationID")
fd_metrics_df$habitat <- factor(fd_metrics_df$habitat, 
                                levels = c("Peat Swamp","Freshwater Swamp","Alluvial Bench",
                                           "Lowland Sandstone", "Lowland Granite", "Upland Granite",
                                           "Montane"), ordered = TRUE)

fd_metrics_df <- left_join(fd_metrics_df, ct_elev[,c("locationID","altitude")])

ft_colors <- c("Peat Swamp" = "#401D00", 
                      "Freshwater Swamp" = "#643E00", 
                      "Alluvial Bench" = "#896007", 
                      "Lowland Sandstone" = "#AF8228", 
                      "Lowland Granite" = "#D3A43B", 
                      "Upland Granite" = "#F4C444",
                      "Montane" = "#FFDD2D")

cmp1 <- ggplot(div_mets[div_mets$n.all > 0,], aes(x = habitat, y = n.all, color = habitat)) +
  geom_boxplot(width = 0.5, outlier.shape = NA) +
  geom_jitter(width = 0.1, size = 1) +
  theme_classic() +
  labs(title = "", x = "", y = "Richness") +
  coord_flip() +
  theme(legend.position = "none") + 
  scale_color_manual(values = ft_colors)

cmp2 <- ggplot(div_mets[div_mets$shannon_ct > 0,], aes(x = habitat, y = shannon_ct, color = habitat)) +
  geom_boxplot(width = 0.5, outlier.shape = NA) +
  geom_jitter(width = 0.1, size = 1) +
  theme_classic() +
  labs(title = "", x = "", y = "Shannon Diversity") +
  coord_flip() +
  theme(legend.position = "none",
         axis.text.y = element_blank()) + 
  scale_color_manual(values = ft_colors)

cmp3 <- ggplot(div_mets[div_mets$div_even > 0,], aes(x = habitat, y = div_even, color = habitat)) +
  geom_boxplot(width = 0.5, outlier.shape = NA) +
  geom_jitter(width = 0.1, size = 1) +
  theme_classic() +
  labs(title = "", x = "", y = "Evenness") +
  coord_flip() +
  theme(legend.position = "none",
         axis.text.y = element_blank()) + 
  scale_color_manual(values = ft_colors)

fdp1 <- ggplot(fd_metrics_df, aes(x = habitat, y = FRich, color = habitat)) +
  geom_boxplot(width = 0.5, outlier.shape = NA) +
  geom_jitter(width = 0.1, size = 1) +
  theme_classic() +
  labs(title = "", x = "", y = "Func. Rich.") +
  coord_flip() +
  theme(plot.title = element_text(hjust = 0.5),
        legend.position = "none") + 
  scale_color_manual(values = ft_colors)

fdp2 <- ggplot(fd_metrics_df, aes(x = habitat, y = FEven, color = habitat)) +
  geom_boxplot(width = 0.5, outlier.shape = NA) +
  geom_jitter(width = 0.1, size = 1) +
  theme_classic() +
  labs(title = "", x = "", y = "Func. Even.") +
  coord_flip() +
  theme(axis.text.y = element_blank(),
        legend.position = "none") + 
  scale_color_manual(values = ft_colors)

fdp3 <- ggplot(fd_metrics_df, aes(x = habitat, y = FDiver, color = habitat)) +
  geom_boxplot(width = 0.5, outlier.shape = NA) +
  geom_jitter(width = 0.1, size = 1) +
  theme_classic() +
  labs(title = "", x = "", y = "Func. Diver.") +
  coord_flip() +
  theme(axis.text.y = element_blank(),
        legend.position = "none") + 
  scale_color_manual(values = ft_colors)

cowplot::plot_grid(cmp1, cmp2, cmp3, fdp1, fdp3, fdp2, nrow = 2, rel_widths = c(.47, .3, .3))

#ggsave("DivMets_by_FT_multiplot.jpg", plot = last_plot(), width = 7.5, height = 5, dpi = 350, device = "jpeg")
```

### Community metrics by elevation

```{r fig.height=4, fig.width=10}
#species richness by elevation - 'all CT locations' and "scanned locations' in the same plot
p1 <- ggplot(div_mets, aes(x = altitude, y = n.all, color = habitat)) +
  geom_jitter(height = 0.2) +
  geom_smooth(se = TRUE, aes(color = NULL)) +  
  scale_color_manual(values = ft_colors) +
  theme_classic() +
  theme(legend.position = "none",
        axis.text.x = element_blank()) + 
  labs(title = "", x = "", y = "Richness")

#shannon diversity by elevation
p2 <- ggplot(div_mets[div_mets$shannon_ct > 0,], aes(x = altitude, y = shannon_ct, color = habitat)) +
  geom_point() +
  geom_smooth(se = TRUE, aes(color = NULL)) +  
  scale_color_manual(values = ft_colors) +
  theme_classic() +
  theme(legend.position = "none",
        axis.text.x = element_blank()) + 
  labs(title = "", x = "", y = "Shannon Diversity")

#species evenness by elevation
p3 <- ggplot(div_mets[div_mets$div_even > 0,], aes(x = altitude, y = div_even, color = habitat)) +
  geom_point() +
  geom_smooth(se = TRUE, aes(color = NULL)) +  
  scale_color_manual(values = ft_colors) +
  theme_classic() +
  theme(legend.position = "none",
        axis.text.x = element_blank()) + 
  labs(title = "", x = "", y = "Evenness")

#functional richness
p4 <- ggplot(fd_metrics_df, aes(x = altitude, y = FRich, color = habitat)) +
  geom_point() +
  geom_smooth(se = TRUE, aes(color = NULL)) +
  scale_color_manual(values = ft_colors) +
  theme_classic() +
  theme(legend.position = "none",) + 
  labs(title = "", x = "", y = "Func. Rich.")

p5 <- ggplot(fd_metrics_df, aes(x = altitude, y = FEven, color = habitat)) +
  geom_point() +
  geom_smooth(se = TRUE, aes(color = NULL)) +  
  scale_color_manual(values = ft_colors) +
  theme_classic() +
  theme(legend.position = "none") + 
  labs(title = "", x = "", y = "Func. Even.")

p6 <- ggplot(fd_metrics_df, aes(x = altitude, y = FDiver, color = habitat)) +
  geom_point() +
  geom_smooth(se = TRUE, aes(color = NULL)) +  
  scale_color_manual(values = ft_colors) +
  theme_classic() +
  theme(legend.position = "none") + 
  labs(title = "", x = "elevation (m)", y = "Func. Diver.")

cowplot::plot_grid(p1,p2,p3,p4,p6,p5, nrow = 2)

#ggsave("DivMets_by_elev_multiplot.jpg", plot = last_plot(), width = 7.5, height = 5, dpi = 350, device = "jpeg")
```


## SPATIAL AUTOCORRELATION

### Global Moran's I 

```{r}
#convert stand mets df to spatial object
stand_mets_sp <- stand_mets
coordinates(stand_mets_sp) <- ~longitude + latitude
proj4string(stand_mets_sp) <- CRS("+proj=longlat +datum=WGS84")

#calculate spatial weights
coords <- coordinates(stand_mets_sp)
distances <- spDists(coords, longlat = TRUE)
max_distance <- max(distances)
threshold <- max_distance * 0.001

#define neighbors based on threshold distance
neighbors <- dnearneigh(coords, 0, threshold)

#binary weights for neighbors
weights <- nb2listw(neighbors, style = "W")

#function to calculate Moran's I and Geary's C
calculate_morans_i <- function(variable, weights) {
  moran_test <- moran.test(variable, weights)
  list(Moran_I = moran_test$estimate[1],
       Expected_I = moran_test$estimate[2],
       Variance = moran_test$estimate[3],
       Z_score = moran_test$statistic,
       P_value = moran_test$p.value)
}

#calculate metrics
metric_list <- c("n.all", "shannon_ct", "div_even")

spac_mets <- map_dfr(metric_list, function(col) {
  metrics <- calculate_morans_i(stand_mets_sp[[col]], weights)
  tibble(Metric = col,
         Moran_I = metrics$Moran_I,
         Expected_I = metrics$Expected_I,
         Variance_I = metrics$Variance,
         Z_score = metrics$Z_score,
         P_value = metrics$P_value,
         Significant = metrics$P_value < 0.05)
})

#again for functional metrics because there's one less observation point, have to run separately
f_metrics_list <- c("FRich", "FEven", "FDiver")
stand_mets_func <- stand_mets[complete.cases(stand_mets[, c("FRich", "FEven", "FDiver")]),
                              c("FRich", "FEven", "FDiver", "longitude", "latitude")]
coordinates(stand_mets_func) <- ~longitude + latitude
proj4string(stand_mets_func) <- CRS("+proj=longlat +datum=WGS84")

coords <- coordinates(stand_mets_func)
distances <- spDists(coords, longlat = TRUE)
max_distance <- max(distances)
threshold <- max_distance * 0.001
neighbors <- dnearneigh(coords, 0, threshold)
weights_pt <- nb2listw(neighbors, style = "W")

spac_mets2 <- map_dfr(f_metrics_list, function(col) {
  metrics <- calculate_morans_i(stand_mets_func[[col]], weights_pt)
  tibble(Metric = col,
         Moran_I = metrics$Moran_I,
         Expected_I = metrics$Expected_I,
         Variance_I = metrics$Variance,
         Z_score = metrics$Z_score,
         P_value = metrics$P_value,
         Significant = metrics$P_value < 0.05)
})

spac_mets %>%
  rbind(spac_mets2) %>%
  arrange(P_value) %>%
  print(n = Inf)
```


Extracting Moran's eigenvector values to use in glm to control for spatial autocorrelation
```{r}
#convert data to sf object
data_sf <- st_as_sf(stand_mets, coords = c("longitude", "latitude"), crs = 4326)
coords <- st_coordinates(data_sf)

#extract Moran's eigenvectors
mev <- meigen(coords, model = "exp", threshold = 0)
eigenvectors <- mev$ev_full
hist(eigenvectors, breaks = 25)

stand_mets <- cbind(stand_mets, eigenvectors)
```


## CREATING SURVEY GRIDS
```{r include=FALSE}
#convert data to sf object
data_sf <- st_as_sf(stand_mets, coords = c("longitude", "latitude"), crs = 4326)

# Define a function to create a grid and count locations
count_grid_cells <- function(grid_size) {
  grid <- st_make_grid(data_sf, cellsize = grid_size, what = "polygons")
  grid_sf <- st_sf(grid_id = seq_along(grid), geometry = grid)
  counts <- st_intersects(grid_sf, data_sf)
  grid_sf$count <- sapply(counts, length)
  list(grid_sf = grid_sf, num_cells = sum(grid_sf$count > 0), grid_size = grid_size)
}

#function to find grid size
find_grid_size <- function(initial_size, min_cells) {
  size <- initial_size
  result <- count_grid_cells(size)
  
  while (result$num_cells < min_cells) {
    size <- size / 2
    result <- count_grid_cells(size)
  }
  
  result
}
```

Run grid size functions
```{r include=FALSE}
#for medium sized grid (~75 ha)
initial_size <- 1 
min_cells <- 15

#find appropriate grid size
result <- find_grid_size(initial_size, min_cells)
final_grid <- result$grid_sf
num_cells <- result$num_cells
as.numeric(st_area(final_grid)[1]) #in m^2

#plot grid
plot(st_geometry(final_grid), col = "white", border = "grey50", main = "Grid with Survey Locations")
plot(st_geometry(data_sf), add = TRUE, col = "grey30", pch = 16)

#how many scanned locations in each grid cell
grid75 <- st_join(data_sf, final_grid, join = st_within)
table(grid75$grid_id)
length(unique(grid75$grid_id))
mean(table(grid75$grid_id))
sd(table(grid75$grid_id))

#add grid designations to stand mets df
stand_mets <- grid75 %>%
  st_drop_geometry() %>%
  dplyr::select(locationID, grid_id) %>%
  rename(grid75 = grid_id) %>%
  left_join(stand_mets, .)

#adding grid to full CT list and then to mammal obs table (m)
ct_sf <- st_as_sf(ct, coords = c("longitude", "latitude"), crs = 4326)
grid75_cells <- st_join(ct_sf, final_grid, join = st_within)

m_filtered <- grid75_cells %>%
  st_drop_geometry() %>%
  dplyr::select(locationID, grid_id) %>%
  rename(grid.75 = grid_id) %>%
  left_join(m_filtered, .)

#write grid as shapefile
#st_write(final_grid, "medium_grid_75ha.shp")

#####################################################################################################
#for large sized grid (~170 ha)
initial_size <- 48 
min_cells <- 10

#find appropriate grid size
result <- find_grid_size(initial_size, min_cells)
final_grid <- result$grid_sf
num_cells <- result$num_cells
as.numeric(st_area(final_grid)[1]) #in m^2

#plot grid
plot(st_geometry(final_grid), col = "white", border = "grey50", main = "Grid with Survey Locations")
plot(st_geometry(data_sf), add = TRUE, col = "grey30", pch = 16)

#how many scanned locations in each grid cell
grid170 <- st_join(data_sf, final_grid, join = st_within)
table(grid170$grid_id)
length(unique(grid170$grid_id))
mean(table(grid170$grid_id))
sd(table(grid170$grid_id))

#add grid designations to stand mets df
stand_mets <- grid170 %>%
  st_drop_geometry() %>%
  dplyr::select(locationID, grid_id) %>%
  rename(grid170 = grid_id) %>%
  left_join(stand_mets, .)

#adding grid to full CT list and then to mammal obs table (m)
grid170_cells <- st_join(ct_sf, final_grid, join = st_within)

m_filtered <- grid170_cells %>%
  st_drop_geometry() %>%
  dplyr::select(locationID, grid_id) %>%
  rename(grid.170 = grid_id) %>%
  left_join(m_filtered, .)

#write grid as shapefile
#st_write(final_grid, "medium_grid_170ha.shp")
```

Again for 650 ha 2X2 
```{r}
grid650 <- read.csv(file = "data/locationID_grid650.csv", header = TRUE)

stand_mets <- grid650 %>%
  dplyr::select(locationID, X650ha_gridID) %>%
  rename(grid650 = X650ha_gridID) %>%
  left_join(stand_mets, .)
```


## MODELING

```{r}
#scale and center numeric predictors
stand_mets <- stand_mets %>% 
  mutate(across(c(5:16, 22:25, 27:29, 37), scale, .names = "{.col}.sc"))
```

#### Descriptions of forest structure metrics used in models

I used {FORTLS} to extract the following metrics:

1.  max.height - maximum height of trees in the stand, in m
2.  mean.tree.h - mean tree height in the stand, in m.
3.  CRR.rho - canopy relief ratio, using rho for horizontal distance. A measure of canopy variation, with lower scores indicating lower local variation in canopy surface, i.e., more uniform age canopy/ less canopy surface complexity.
4.  sd.r - standard deviation of tree heights in stand in m. I've seen this value used as an approximation for vertical stratification.
5.  mean.dbh - mean diameter at breast height of trees in stand, in cm (measured at height of 1.3m)
6.  basal.area - basal area of trees in the stand (m2/ha)
7.  stand.dens - density of trees in the stand (trees/ha)
8.  stem.vol - volume of trees in the stand (m3/ha)
9.  pts.below.2m - shows the number of points in the point cloud that are below 2m.

I used {lidr} and {lidRmetrics} to extract the following metrics:

10. zentropy - normalized Shannon diversity index of z (height) values. Describes vertical complexity.
11. lad.max - Leaf Area Density maximum value for 1m vertical bins. Describes maximum foliage cover of the point cloud.
12. rumple - Rumple index (rugosity), a ratio of the canopy surface area to it's projected ground area.
vn - number of 1m voxels created for the following volumetric metrics.
13. vFRcanopy - ratio of filled to empty voxels, only counting cells within and below canopy, ignoring above.
14. vzrumple - vertical Rumple index.
15. ClosedGapSpace - volume of voxels that are classified as gaps underneath the canopy

#### Correlation between community metrics and predictors.
```{r}
df <- stand_mets[, c("mean.tree.h.sc", "sd.r.sc", "mean.dbh.sc", "basal.area.sc", "stand.dens.sc", 
                     "stem.vol.sc", "pts.below.2m.sc", "lad.max.sc", "ClosedGapSpace.sc", "vFRcanopy.sc",
                     "zentropy.sc", "vzrumple.sc", "n.all", "shannon_ct", "div_even", "FEven", "FDiver")]

colnames.list <- c("tree h mean", "tree h sd", "tree dbh", "basal area", "tree density", 
                   "stem volume", "near-ground veg.", "leaf area density", "gap volume", "veg. volume",
                   "vertical pt. dist.", "vertical pt. complex.", "Species Richness", "Shannon Diversity", 
                   "Species Evenness", "Funct. Evenness", "Funct. Divergence")

colnames(df) <- colnames.list 

#corrplot
corr_results <- rcorr(as.matrix(df), type = "spearman")

cor_matrix <- corr_results$r
p_matrix <- corr_results$P 

#save plot
#jpeg("SpearCorrCT.jpg", width = 7, height = 8.5, units = "in", res = 500)

corrplot(cor_matrix,
         method = "color",          
         type = "upper",            
         tl.col = "black",          
         tl.srt = 45,               
         tl.cex = 0.8,              
         cl.pos = "r",              
         addCoef.col = TRUE,
         number.cex = 0.6,
         number.font = 1,
         diag = FALSE)

dev.off()
```


### Models by camera trap location
Fitting global model then using {dredge} to find models of best fit
```{r}
stand_mets$log.act.days <- log(stand_mets$act.days)
```


#### Species richness model

```{r message=FALSE, warning=FALSE, include=FALSE}
stand_mets$eigenvectors.sc <- as.numeric(stand_mets$eigenvectors.sc)
stand_mets$ClosedGapSpace.sc <- as.numeric(stand_mets$ClosedGapSpace.sc)
stand_mets$vFRcanopy.sc <- as.numeric(stand_mets$vFRcanopy.sc)
stand_mets$stand.dens.sc <- as.numeric(stand_mets$stand.dens.sc)
stand_mets$basal.area.sc <- as.numeric(stand_mets$basal.area.sc)


#fitting global model for use in dredge
rm1 <- glm(n.all ~  
             mean.tree.h.sc +
             sd.r.sc +
             mean.dbh.sc +
             basal.area.sc + 
             stand.dens.sc +
             stem.vol.sc +
             pts.below.2m.sc +
             zentropy.sc +
             lad.max.sc +
             vFRcanopy.sc +
             vzrumple.sc +
             eigenvectors.sc +
             ClosedGapSpace.sc,
           na.action = na.fail,
           family = Gamma(link = "log"), 
           offset = log.act.days,
           data = stand_mets)
#dredge
rich_models <- dredge(rm1, m.max = 2, extra = "deviance",
                      subset = !(basal.area.sc && stand.dens.sc) && 
                               !(basal.area.sc && stem.vol.sc),
                      fixed = "eigenvectors.sc")
#deviance
rich_models
```

```{r}
#plot full model
broom::tidy(rm1) %>%
  filter(term != "(Intercept)", term != "eigenvectors.sc", 
         !grepl("^partition", term), !grepl("^as\\.factor\\(grid75\\)", term)) %>%
  mutate(ci95_low = estimate - 1.96 * std.error,
    ci95_high = estimate + 1.96 * std.error,
    ci50_low = estimate - 0.674 * std.error,
    ci50_high = estimate + 0.674 * std.error) %>%
  ggplot(aes(x = reorder(term, -estimate), y = estimate)) +
  geom_point() +
  geom_errorbar(aes(ymin = ci95_low, ymax = ci95_high), width = 0) +        
  geom_errorbar(aes(ymin = ci50_low, ymax = ci50_high), width = 0, size = 1.4) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "black") +
  labs(x = "", y = "coefficient estimate", title = "Richness Full Model") +
  theme_classic() +
  coord_flip()
```

averaged model output - averaging all models

```{r}
#averaging models
rich_models_avg <- model.avg(rich_models)
#summary(rich_models_avg)

plot(rich_models_avg, full = FALSE, intercept = FALSE, main = "Terrestrial Mammal Richness - Averaged Model")
```


```{r}
#plot comparing full model to model averaged outputs
bind_rows(broom::tidy(rm1) %>%
            filter(term != "(Intercept)", term != "eigenvectors.sc", !grepl("^partition", term)) %>%
            mutate(model = "full model"),
          summary(rich_models_avg)$coefmat.subset %>%
            as.data.frame() %>%
            rownames_to_column("term") %>%
            filter(term != "(Intercept)", term != "eigenvectors.sc", !grepl("^partition", term)) %>%
            rename(estimate = Estimate, std.error = `Std. Error`) %>%
            mutate(model = "averaged model")) %>%
  ggplot(aes(x = reorder(term, -estimate), y = estimate, color = model)) +
  geom_errorbar(aes(ymin = estimate - std.error,
                    ymax = estimate + std.error),
                width = 0, position = position_dodge(width = 0.5)) +
  geom_point(position = position_dodge(width = 0.5), size = 2.5) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  coord_flip() +
  labs(x = "", y = "coefficient estimate", title = "Richness Models Comparison",
       color = "") +
  theme_classic() +
  theme(legend.position = "bottom")
```


#### Shannon diversity model

```{r message=FALSE, warning=FALSE}
#species diversity as outcome variable - by CT location
shannon_model <- glm(shannon_ct ~ 
                         mean.tree.h.sc +
                         sd.r.sc +
                         mean.dbh.sc +
                         basal.area.sc +
                         stand.dens.sc +
                         stem.vol.sc +
                         pts.below.2m.sc +
                         zentropy.sc +
                         lad.max.sc +
                         vFRcanopy.sc +
                         vzrumple.sc +
                         eigenvectors.sc +
                         ClosedGapSpace.sc,
                        na.action = na.fail,
                        family = Gamma(link = "log"), 
                        offset = log.act.days,
                        data = stand_mets)
#dredge
shan_models <- dredge(shannon_model, m.max = 2, extra = "deviance",
                      subset = !(basal.area.sc && stand.dens.sc) && 
                               !(basal.area.sc && stem.vol.sc),
                      fixed = "eigenvectors.sc")

#deviance
shan_models
```

averaged model output - averaging all models

```{r}
#averaging models
shan_models_avg <- model.avg(shan_models)
summary(shan_models_avg)

plot(shan_models_avg, full = FALSE, intercept = FALSE, main = "Terrestrial Mammal Diversity - Averaged Model")
```


```{r}
#plot comparing full model to model averaged outputs
bind_rows(broom::tidy(shannon_model) %>%
            filter(!term %in% c("(Intercept)", "eigenvectors.sc")) %>%
            mutate(model = "full model"),
          summary(shan_models_avg)$coefmat.subset %>%
            as.data.frame() %>%
            rownames_to_column("term") %>%
            filter(!term %in% c("(Intercept)", "eigenvectors.sc")) %>%
            rename(estimate = Estimate, std.error = `Std. Error`) %>%
            mutate(model = "averaged model")) %>%
  ggplot(aes(x = reorder(term, -estimate), y = estimate, color = model)) +
  geom_errorbar(aes(ymin = estimate - std.error,
                    ymax = estimate + std.error),
                width = 0, position = position_dodge(width = 0.5)) +
  geom_point(position = position_dodge(width = 0.5), size = 2.5) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  coord_flip() +
  labs(x = "", y = "coefficient estimate", title = "Shannon Models Comparison",
       color = "") +
  theme_classic() +
  theme(legend.position = "bottom")
```


#### Species evenness model

```{r message=FALSE, warning=FALSE, include=FALSE}
even_model <- glm(div_even ~ 
                mean.tree.h.sc +
                sd.r.sc +
                mean.dbh.sc +
                basal.area.sc +
                stand.dens.sc +
                stem.vol.sc +
                pts.below.2m.sc +
                zentropy.sc +
                lad.max.sc +
                vFRcanopy.sc +
                vzrumple.sc +
                eigenvectors.sc +
                ClosedGapSpace.sc,
                na.action = na.fail,
              family = Gamma(link = "log"), 
              offset = log.act.days,
              data = stand_mets)
#dredge
even_models <- dredge(even_model, m.max = 2, extra = "deviance",
                      subset = !(basal.area.sc && stand.dens.sc) && 
                               !(basal.area.sc && stem.vol.sc),
                      fixed = "eigenvectors.sc")

#deviance
even_models
```

averaged model output - averaging all models

```{r}
#averaging all models
even_models_avg <- model.avg(even_models)
#summary(even_models_avg)

plot(even_models_avg, full = FALSE, intercept = FALSE, main = "Terrestrial Mammal Evenness - Avg. Model")
```

#### Functional richness model

Top model summary output

```{r message=FALSE, warning=FALSE, include=FALSE}
stand_mets_FD$stand.dens.sc <- as.numeric(stand_mets_FD$stand.dens.sc)
stand_mets_FD$basal.area.sc <- as.numeric(stand_mets_FD$basal.area.sc)
stand_mets_FD$mean.dbh.sc <- as.numeric(stand_mets_FD$mean.dbh.sc)

stand_mets_FD <- stand_mets[!is.na(stand_mets$FRich),]

frich_model <- glm(FRich ~ 
                mean.tree.h.sc +
                sd.r.sc +
                mean.dbh.sc +
                basal.area.sc +
                stand.dens.sc +
                stem.vol.sc +
                pts.below.2m.sc +
                zentropy.sc +
                lad.max.sc +
                vFRcanopy.sc +
                vzrumple.sc +
                eigenvectors.sc +
                ClosedGapSpace.sc,
                na.action = na.fail,
              family = Gamma(link = "log"), 
              offset = log.act.days,      
              data = stand_mets_FD)
#dredge
frich_models <- dredge(frich_model, m.max = 2, extra = "deviance",
                      subset = !(basal.area.sc && stand.dens.sc) && 
                               !(basal.area.sc && stem.vol.sc))

#deviance
frich_models
```

averaged model output - averaging all models

```{r}
frich_models_avg <- model.avg(frich_models)
#summary(frich_models_avg)

plot(frich_models_avg, full = FALSE, intercept = FALSE, main = "Functional Richness - Avg. Model")
```

#### Functional evenness model

Top model summary output

```{r message=FALSE, warning=FALSE, include=FALSE}
feven_model <- glm(FEven ~ 
                mean.tree.h.sc +
                sd.r.sc +
                mean.dbh.sc +
                basal.area.sc +
                stand.dens.sc +
                stem.vol.sc +
                pts.below.2m.sc +
                zentropy.sc +
                lad.max.sc +
                vFRcanopy.sc +
                vzrumple.sc +
                ClosedGapSpace.sc,
                na.action = na.fail,
              family = Gamma(link = "log"), 
              offset = log.act.days,
              data = stand_mets_FD)
#dredge
feven_models <- dredge(feven_model, m.max = 2, extra = "deviance",
                      subset = !(basal.area.sc && stand.dens.sc) && 
                               !(basal.area.sc && stem.vol.sc))

#deviance
feven_models
```

averaged model output - averaging all models

```{r message=FALSE, warning=FALSE, include=FALSE}
feven_models_avg <- model.avg(feven_models)
summary(feven_models_avg)
```

```{r}
plot(feven_models_avg, full = FALSE, intercept = FALSE, main = "Functional Evenness - Avg. Model")
```


#### Functional divergence model

Top model summary output

```{r message=FALSE, warning=FALSE, include=FALSE}
fdiver_model <- glm(FDiver ~ 
                mean.tree.h.sc +
                sd.r.sc +
                mean.dbh.sc +
                basal.area.sc +
                stand.dens.sc +
                stem.vol.sc +
                pts.below.2m.sc +
                zentropy.sc +
                lad.max.sc +
                vFRcanopy.sc +
                vzrumple.sc +
                eigenvectors.sc +
                ClosedGapSpace.sc,
                na.action = na.fail,
              family = Gamma(link = "log"), 
              offset = log.act.days,
              data = stand_mets_FD)
#dredge
fdiver_models <- dredge(fdiver_model, m.max = 2, extra = "deviance",
                      subset = !(basal.area.sc && stand.dens.sc) && 
                               !(basal.area.sc && stem.vol.sc),
                      fixed = "eigenvectors.sc")

#deviance
fdiver_models
```

averaged model output - averaging all models

```{r message=FALSE, warning=FALSE, include=FALSE}
fdiver_models_avg <- model.avg(fdiver_models)
summary(fdiver_models_avg)
```

```{r}
plot(fdiver_models_avg, full = FALSE, intercept = FALSE, main = "Functional Divergence - Avg. Model")
```


#### Comparing coefficient plot from averaged models

```{r fig.height=5, fig.width=6}
#function to extract coefficients and confidence intervals
extract_coefs <- function(model_avg, model_name) {
  coefs <- as.data.frame(confint(model_avg))
  coefs$predictor <- rownames(coefs)
  coefs$estimate <- coef(model_avg)
  coefs$model <- model_name
  confint50 <- confint(model_avg, level = 0.5)
  coefs$`25 %` <- confint50[, 1]
  coefs$`75 %` <- confint50[, 2]
  return(coefs)
}

#extract coefficients from averaged models
coef_rich <- extract_coefs(rich_models_avg, "rich")
coef_shan <- extract_coefs(shan_models_avg, "shan")
coef_even <- extract_coefs(even_models_avg, "even")
coef_fric <- extract_coefs(frich_models_avg, "fric")
coef_feve <- extract_coefs(feven_models_avg, "feve")
coef_fdiv <- extract_coefs(fdiver_models_avg, "fdiv")

#combine all
coef_df <- rbind(coef_rich, coef_shan, coef_even, coef_fric, coef_feve, coef_fdiv)
rm(coef_rich, coef_shan, coef_even, coef_fric, coef_feve, coef_fdiv)

#specifying order to plot models
coef_df$model <- factor(coef_df$model, levels = rev(c("rich","shan","even","fric","feve","fdiv")))

#select only predictors with 95% CI's that don't overlap zero
coef_df_filter <- coef_df[!(coef_df$`2.5 %` <= 0 & coef_df$`97.5 %` >= 0),]
coef_df_filter <- coef_df_filter[!coef_df_filter$predictor %in% c("(Intercept)", "eigenvectors.sc"),]

#plotting
coef_df_filter %>%
  filter(!model %in% c("fric")) %>%
ggplot(aes(x = estimate, y = predictor, color = model)) +
  geom_point(position = position_dodge(width = 0.5), size = 3) +
  geom_errorbar(aes(xmin = `2.5 %`, xmax = `97.5 %`), width = 0, 
                position = position_dodge(width = 0.5)) +
  geom_errorbar(aes(xmin = `25 %`, xmax = `75 %`), width = 0, 
                position = position_dodge(width = 0.5), size = 1.5, linetype = "solid") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "grey50") +
  theme_classic() +
  labs(title = "Reliable Predictors from Averaged CT Models",
       x = "Coefficient Estimate", y = "") +
  theme(axis.text.y = element_text(hjust = 1),
        legend.position = "bottom") +
  guides(color = guide_legend(reverse = TRUE))
```


### MODELS BY GRID

#### 75 ha grid

```{r include=FALSE}
#species richness
grid75_mets <- m_filtered %>%
  group_by(grid.75) %>%
  summarise(n.all = n_distinct(Species))

#shannon diversity
shannon_75 <- diversity(table(m_filtered$grid.75, m_filtered$Species), index = "shannon")
shannon_75 <- rownames_to_column(as.data.frame(shannon_75), var = "grid.75")
shannon_75$grid.75 <- as.integer(shannon_75$grid.75)

#species evenness
grid75_mets <- shannon_75 %>%
  left_join(., grid75_mets) %>%
  mutate(even.75 = shannon_75/log(n.all))

### functional metrics ###
#creating observation table by partition
obs_table_75 <- m_filtered %>%
  filter(Species %in% terr_traits$Species) %>%
  filter(!Species %in% c("Tragulus spp.","Unid civet","Unid Rat","Muntiacus spp.")) %>%
  group_by(grid.75, Species) %>%
  summarise(n.ind = sum(Number.of.Animals)) %>%
  pivot_wider(names_from = Species, values_from = n.ind)

#adding survey effort
ct_active_days <- grid75_cells %>%
  st_drop_geometry() %>%
  rename(grid.75 = grid_id) %>%
  dplyr::select(c(locationID, grid.75)) %>%
  left_join(ct_active_days, .)

obs_table_75 <- ct_active_days %>%
  group_by(grid.75) %>%
  summarise(act.days = sum(act.days)) %>%
  left_join(obs_table_75, ., by = "grid.75")

grid75_mets <- left_join(grid75_mets, obs_table_75[,c("grid.75", "act.days")])

#standardizing by survey effort and assigning partition to row names
#obs_table_75 <- obs_table_75 %>% mutate(across(-0, ~ . / act.days))

obs_table_75 <- as.data.frame(obs_table_75)
obs_table_75 <- obs_table_75[-22,]
rownames(obs_table_75) <- obs_table_75$grid.75
obs_table_75 <- obs_table_75[,-c(1, 37)]

#placing column names in alphabetical order
obs_table_75 <- obs_table_75[, order(names(obs_table_75))]

#calculating FD mets by partition
fd_metrics_75 <- dbFD(terr_traits_trim, obs_table_75)

#subset of metrics of interest
fd_metrics_75_df <- data.frame(
  grid.75 = as.numeric(rownames(as.data.frame(fd_metrics_75$FRic))), 
  FRich = fd_metrics_75$FRic, 
  FEven = fd_metrics_75$FEve, 
  FDiver = fd_metrics_75$FDiv, 
  stringsAsFactors = FALSE)

#add to metrics table
grid75_mets <- left_join(grid75_mets, fd_metrics_75_df, by = "grid.75")

#### calculating mean of all scaled predictors by grid cell
grid75_mets <- stand_mets %>%
  group_by(grid75) %>%
  dplyr::select(ends_with(".sc")) %>%
  summarize(across(where(is.numeric), mean, na.rm = TRUE)) %>%
  rename(grid.75 = grid75) %>%
  dplyr::select(-eigenvectors.sc) %>%
  left_join(grid75_mets, .)

#add number of scanned locations to df
grid75_mets <- as.data.frame(table(grid75$grid_id)) %>%
  rename(grid.75 = Var1,
         n.scanned = Freq) %>%
  mutate(grid.75 = as.numeric(as.character(grid.75))) %>%
  left_join(grid75_mets, ., by = "grid.75")
```


#### Correlation of structure metrics
```{r}
df <- grid75_mets[, c("mean.tree.h.sc", "sd.r.sc", "mean.dbh.sc", "basal.area.sc", "stand.dens.sc", 
                     "stem.vol.sc", "pts.below.2m.sc", "lad.max.sc", "ClosedGapSpace.sc", "vFRcanopy.sc",
                     "zentropy.sc", "vzrumple.sc", "n.all", "shannon_75", "even.75", "FEven", "FDiver")]

colnames(df) <- colnames.list

#corrplot
corr_results <- rcorr(as.matrix(df), type = "spearman")

cor_matrix <- corr_results$r
p_matrix <- corr_results$P 

#save plot
#jpeg("SpearCorr75.jpg", width = 7, height = 8.5, units = "in", res = 500)

corrplot(cor_matrix,
         method = "color",          
         type = "upper",            
         tl.col = "black",          
         tl.srt = 45,               
         tl.cex = 0.8,              
         cl.pos = "r",              
         addCoef.col = TRUE,
         number.cex = 0.6,
         number.font = 1,
         diag = FALSE)

#dev.off()
```

#### Species richness model

Fitting global model then using {dredge} to find models of best fit
```{r message=FALSE, warning=FALSE, include=FALSE}
grid75_mets$log.act.days <- log(grid75_mets$act.days)

#removing cells without structure metrics
grid75_mets <- grid75_mets[complete.cases(grid75_mets),]

#fitting global model for use in dredge
rm_75 <- glm(n.all ~ 
             mean.tree.h.sc +
             sd.r.sc +
             mean.dbh.sc +
             basal.area.sc + 
             stand.dens.sc +
             stem.vol.sc +
             pts.below.2m.sc +
             zentropy.sc +
             lad.max.sc +
             vFRcanopy.sc +
             vzrumple.sc +
             ClosedGapSpace.sc,
           na.action = na.fail,
           family = Gamma(link = "log"), 
           offset = log.act.days,
           weights = n.scanned,          #control for n scanned locations per cell 
           data = grid75_mets)

#dredge
rich_75_models <- dredge(rm_75, m.max = 2, extra = "deviance",
                      subset = !(basal.area.sc && stand.dens.sc) && 
                               !(mean.tree.h.sc && vzrumple.sc))
#deviance
rich_75_models
```

averaged model output - averaging all models

```{r message=FALSE, warning=FALSE, include=FALSE}
rich_models_75_avg <- model.avg(rich_75_models)
summary(rich_models_75_avg)
```

```{r}
plot(rich_models_75_avg, full = FALSE, intercept = FALSE, main = "Mammal Richness (75 ha grid) - Av. Mod")
```

#### Species diversity model

```{r message=FALSE, warning=FALSE, include=FALSE}
#fitting global model for use in dredge
sm_75 <- glm(shannon_75 ~ 
             mean.tree.h.sc +
             sd.r.sc +
             mean.dbh.sc +
             basal.area.sc + 
             stand.dens.sc +
             stem.vol.sc +
             pts.below.2m.sc +
             zentropy.sc +
             lad.max.sc +
             vFRcanopy.sc +
             vzrumple.sc +
             ClosedGapSpace.sc,
           na.action = na.fail,
           family = Gamma(link = "log"), 
           offset = log.act.days,
           weights = n.scanned,
           data = grid75_mets)

#dredge
shan_75_models <- dredge(sm_75, m.max = 2, extra = "deviance",
                      subset = !(basal.area.sc && stand.dens.sc) && 
                               !(mean.tree.h.sc && vzrumple.sc))

#deviance
shan_75_models
```

averaged model output - averaging all models

```{r message=FALSE, warning=FALSE, include=FALSE}
shan_models_75_avg <- model.avg(shan_75_models)
summary(shan_models_75_avg)
```

```{r}
plot(shan_models_75_avg, full = FALSE, intercept = FALSE, main = "Mammal Diversity (75 ha grid) - Av. Mod")
```

#### Species eveness model

```{r message=FALSE, warning=FALSE, include=FALSE}
#fitting global model for use in dredge
em_75 <- glm(even.75 ~ 
             mean.tree.h.sc +
             sd.r.sc +
             mean.dbh.sc +
             basal.area.sc + 
             stand.dens.sc +
             stem.vol.sc +
             pts.below.2m.sc +
             zentropy.sc +
             lad.max.sc +
             vFRcanopy.sc +
             vzrumple.sc +
             ClosedGapSpace.sc,
           na.action = na.fail,
           family = Gamma(link = "log"), 
           offset = log.act.days,
           weights = n.scanned,
           data = grid75_mets)

#dredge
even_75_models <- dredge(em_75, m.max = 2, extra = "deviance",
                      subset = !(basal.area.sc && stand.dens.sc) && 
                               !(mean.tree.h.sc && vzrumple.sc))
#deviance
even_75_models
```

averaged model output - averaging all models

```{r message=FALSE, warning=FALSE, include=FALSE}
even_models_75_avg <- model.avg(even_75_models)
summary(even_models_75_avg)
```

```{r}
plot(even_models_75_avg, full = FALSE, intercept = FALSE, main = "Mammal Evenness (75 ha grid) - Av. Mod")
```

#### Functional richness model

```{r message=FALSE, warning=FALSE, include=FALSE}
#fitting global model for use in dredge
fr_75 <- glm(FRich ~ 
             mean.tree.h.sc +
             sd.r.sc +
             mean.dbh.sc +
             basal.area.sc + 
             stand.dens.sc +
             stem.vol.sc +
             pts.below.2m.sc +
             zentropy.sc +
             lad.max.sc +
             vFRcanopy.sc +
             vzrumple.sc +
             ClosedGapSpace.sc,
           na.action = na.fail,
           family = Gamma(link = "log"), 
           offset = log.act.days,
           weights = n.scanned,
           data = grid75_mets)

#dredge
frich_75_models <- dredge(fr_75, m.max = 2, 
                      subset = !(basal.area.sc && stand.dens.sc) && 
                               !(mean.tree.h.sc && vzrumple.sc))
```

averaged model output - averaging all models

```{r message=FALSE, warning=FALSE, include=FALSE}
frich_models_75_avg <- model.avg(frich_75_models)
summary(frich_models_75_avg)
```

```{r}
plot(frich_models_75_avg, full = FALSE, intercept = FALSE, main = "Mammal FRich (75 ha grid) - Av. Mod")
```

#### Functional evenness model

```{r message=FALSE, warning=FALSE, include=FALSE}
#fitting global model for use in dredge
fe_75 <- glm(FEven ~ 
             mean.tree.h.sc +
             sd.r.sc +
             mean.dbh.sc +
             basal.area.sc + 
             stand.dens.sc +
             stem.vol.sc +
             pts.below.2m.sc +
             zentropy.sc +
             lad.max.sc +
             vFRcanopy.sc +
             vzrumple.sc +
             ClosedGapSpace.sc,
           na.action = na.fail,
           family = Gamma(link = "log"), 
           offset = log.act.days,
           weights = n.scanned,
           data = grid75_mets)

#dredge
feven_75_models <- dredge(fe_75, m.max = 2, extra = "deviance",
                      subset = !(basal.area.sc && stand.dens.sc) && 
                               !(mean.tree.h.sc && vzrumple.sc))
#deviance
feven_75_models
```

averaged model output - averaging all models

```{r message=FALSE, warning=FALSE, include=FALSE}
feven_models_75_avg <- model.avg(feven_75_models)
summary(feven_models_75_avg)
```

```{r}
plot(feven_models_75_avg, full = FALSE, intercept = FALSE, main = "Mammal FEven (75 ha grid) - Av. Mod")
```

#### Functional divergence model

```{r message=FALSE, warning=FALSE, include=FALSE}
#fitting global model for use in dredge
fd_75 <- glm(FDiver ~ 
             mean.tree.h.sc +
             sd.r.sc +
             mean.dbh.sc +
             basal.area.sc + 
             stand.dens.sc +
             stem.vol.sc +
             pts.below.2m.sc +
             zentropy.sc +
             lad.max.sc +
             vFRcanopy.sc +
             vzrumple.sc +
             ClosedGapSpace.sc,
           na.action = na.fail,
           family = Gamma(link = "log"), 
           offset = log.act.days,
           weights = n.scanned,
           data = grid75_mets)

#dredge
fdiver_75_models <- dredge(fd_75, m.max = 2, extra = "deviance",
                      subset = !(basal.area.sc && stand.dens.sc) && 
                               !(mean.tree.h.sc && vzrumple.sc))
#deviance
fdiver_75_models
```

averaged model output - averaging all models

```{r message=FALSE, warning=FALSE, include=FALSE}
fdiver_models_75_avg <- model.avg(fdiver_75_models)
summary(fdiver_models_75_avg)
```

```{r}
plot(fdiver_models_75_avg, full = FALSE, intercept = FALSE, main = "Mammal FDiver (75 ha grid) - Av. Mod")
```


#### Comparing coefficient plots from averaged models

Only for shannon diveristy and functional models, based on high degree of correlation with the other community metrics
```{r fig.height=7, fig.width=6}
#extract coefficients from averaged models
coef_rich <- extract_coefs(rich_models_75_avg, "rich")
coef_shan <- extract_coefs(shan_models_75_avg, "shan")
coef_even <- extract_coefs(even_models_75_avg, "even")
coef_fric <- extract_coefs(frich_models_75_avg, "fric")
coef_feve <- extract_coefs(feven_models_75_avg, "feve")
coef_fdiv <- extract_coefs(fdiver_models_75_avg, "fdiv")

#combine all
coef_df <- rbind(coef_rich, coef_shan, coef_even, coef_fric, coef_feve, coef_fdiv)
rm(coef_rich, coef_shan, coef_even, coef_fric, coef_feve, coef_fdiv)

#specifying order to plot models
coef_df$model <- factor(coef_df$model, levels = rev(c("rich","shan","even","fric","feve","fdiv")))

#select only predictors with 50% CI's that don't overlap zero
coef_df_filter <- coef_df[!(coef_df$`2.5 %` <= 0 & coef_df$`97.5 %` >= 0),]
coef_df_filter <- coef_df_filter[!coef_df_filter$predictor %in% c("(Intercept)", "eigenvectors.sc"),]

#plotting - only the functional models for now
coef_df_filter %>%
  filter(!model %in% c("fric")) %>%
ggplot(aes(x = estimate, y = predictor, color = model)) +
  geom_point(position = position_dodge(width = 0.5), size = 3) +
  geom_errorbar(aes(xmin = `2.5 %`, xmax = `97.5 %`), width = 0, 
                position = position_dodge(width = 0.5)) +
  geom_errorbar(aes(xmin = `25 %`, xmax = `75 %`), width = 0, 
                position = position_dodge(width = 0.5), size = 1.5, linetype = "solid") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "grey50") +
  theme_classic() +
  labs(title = "Reliable Predictors from Avg. 75ha grid Models",
       x = "Coefficient Estimate", y = "") +
  theme(axis.text.y = element_text(hjust = 1),
        legend.position = "bottom") +
  guides(color = guide_legend(reverse = TRUE))
```

#### 170 ha grid

The 170 ha grid creates 10 groups (grid cells) 
```{r include=FALSE}
#species richness
#all CT locations
grid170_mets <- m_filtered %>%
  group_by(grid.170) %>%
  summarise(n.all = n_distinct(Species))

#shannon diversity
shannon_170 <- diversity(table(m_filtered$grid.170, m_filtered$Species), index = "shannon")
shannon_170 <- rownames_to_column(as.data.frame(shannon_170), var = "grid.170")
shannon_170$grid.170 <- as.integer(shannon_170$grid.170)

#species evenness
grid170_mets <- shannon_170 %>%
  left_join(., grid170_mets) %>%
  mutate(even.170 = shannon_170/log(n.all))

### functional metrics ###
#creating observation table by partition
obs_table_170 <- m_filtered %>%
  filter(Species %in% terr_traits$Species) %>%
  filter(!Species %in% c("Tragulus spp.","Unid civet","Unid Rat","Muntiacus spp.")) %>%
  group_by(grid.170, Species) %>%
  summarise(n.ind = sum(Number.of.Animals)) %>%
  pivot_wider(names_from = Species, values_from = n.ind)

#adding survey effort
ct_active_days <- grid170_cells %>%
  st_drop_geometry() %>%
  rename(grid.170 = grid_id) %>%
  dplyr::select(c(locationID, grid.170)) %>%
  left_join(ct_active_days, .)

obs_table_170 <- ct_active_days %>%
  group_by(grid.170) %>%
  summarise(act.days = sum(act.days)) %>%
  left_join(obs_table_170, ., by = "grid.170")

grid170_mets <- left_join(grid170_mets, obs_table_170[,c("grid.170", "act.days")])

#standardizing by survey effort and assigning partition to row names
#obs_table_170 <- obs_table_170 %>% mutate(across(-0, ~ . / act.days))

obs_table_170 <- as.data.frame(obs_table_170)
obs_table_170 <- obs_table_170[-13,] #drop NA row
rownames(obs_table_170) <- obs_table_170$grid.170
obs_table_170 <- obs_table_170[,-c(1, 37)]

#placing column names in alphabetical order
obs_table_170 <- obs_table_170[, order(names(obs_table_170))]

#calculating FD mets by partition
fd_metrics_170 <- dbFD(terr_traits_trim, obs_table_170)

#subset of metrics of interest
fd_metrics_170_df <- data.frame(
  grid.170 = as.numeric(rownames(as.data.frame(fd_metrics_170$FRic))), 
  FRich = fd_metrics_170$FRic, 
  FEven = fd_metrics_170$FEve, 
  FDiver = fd_metrics_170$FDiv, 
  stringsAsFactors = FALSE)

#add to metrics table
grid170_mets <- left_join(grid170_mets, fd_metrics_170_df, by = "grid.170")

#### calculating mean of all scaled predictors by grid cell
#two of the 12 cells do not have scanned locations and so will be dropped from the models below
grid170_mets <- stand_mets %>%
  group_by(grid170) %>%
  dplyr::select(ends_with(".sc")) %>%
  summarize(across(where(is.numeric), mean, na.rm = TRUE)) %>%
  rename(grid.170 = grid170) %>%
  dplyr::select(-eigenvectors.sc) %>%
  left_join(grid170_mets, .)

#add number of scanned locations to df
grid170_mets <- as.data.frame(table(grid170$grid_id)) %>%
  rename(grid.170 = Var1,
         n.scanned = Freq) %>%
  mutate(grid.170 = as.numeric(as.character(grid.170))) %>%
  left_join(grid170_mets, ., by = "grid.170")
```


#### Correlation of structure metrics
```{r}
df <- grid170_mets[, c("mean.tree.h.sc", "sd.r.sc", "mean.dbh.sc", "basal.area.sc", "stand.dens.sc", 
                     "stem.vol.sc", "pts.below.2m.sc", "lad.max.sc", "ClosedGapSpace.sc", "vFRcanopy.sc",
                     "zentropy.sc", "vzrumple.sc", "n.all", "shannon_170", "even.170", "FEven", "FDiver")]

colnames(df) <- colnames.list

#corrplot
corr_results <- rcorr(as.matrix(df), type = "spearman")

cor_matrix <- corr_results$r
p_matrix <- corr_results$P 

#save plot
#jpeg("SpearCorr170.jpg", width = 7, height = 8.5, units = "in", res = 500)

corrplot(cor_matrix,
         method = "color",          
         type = "upper",            
         tl.col = "black",          
         tl.srt = 45,               
         tl.cex = 0.8,              
         cl.pos = "r",              
         addCoef.col = TRUE,
         number.cex = 0.6,
         number.font = 1,
         diag = FALSE)

#dev.off()
```

#### Species richness model

```{r message=FALSE, warning=FALSE, include=FALSE}
grid170_mets$log.act.days <- log(grid170_mets$act.days)

#removing MO1 partition since no structure mets are from this pt
grid170_mets <- grid170_mets[complete.cases(grid170_mets),]

#fitting global model for use in dredge
rm_170 <- glm(n.all ~ 
             mean.tree.h.sc +
             sd.r.sc +
             mean.dbh.sc +
             basal.area.sc + 
             stand.dens.sc +
             stem.vol.sc +
             pts.below.2m.sc +
             zentropy.sc +
             lad.max.sc +
             vFRcanopy.sc +
             vzrumple.sc +
             ClosedGapSpace.sc,
           na.action = na.fail,
           family = Gamma(link = "log"), 
           offset = log.act.days,
           weights = n.scanned,
           data = grid170_mets)

#dredge
rich_170_models <- dredge(rm_170, m.max = 2, extra = "deviance",
                      subset = !(basal.area.sc && stand.dens.sc)) 

#deviance information
rich_170_models
```

averaged model output - averaging all models

```{r message=FALSE, warning=FALSE, include=FALSE}
rich_models_170_avg <- model.avg(rich_170_models)
summary(rich_models_170_avg)
```

```{r}
plot(rich_models_170_avg, full = FALSE, intercept = FALSE, main = "Mammal Richness (170 ha grid) - Av. Mod")
```

#### Species diversity model

```{r message=FALSE, warning=FALSE, include=FALSE}
#fitting global model for use in dredge
sm_170 <- glm(shannon_170 ~ 
             mean.tree.h.sc +
             sd.r.sc +
             mean.dbh.sc +
             basal.area.sc + 
             stand.dens.sc +
             stem.vol.sc +
             pts.below.2m.sc +
             zentropy.sc +
             lad.max.sc +
             vFRcanopy.sc +
             vzrumple.sc +
             ClosedGapSpace.sc,
           na.action = na.fail,
           family = Gamma(link = "log"), 
           offset = log.act.days,
           weights = n.scanned,
           data = grid170_mets)

summary(sm_170)

#dredge
shan_170_models <- dredge(sm_170, m.max = 2, extra = "deviance",
                      subset = !(basal.area.sc && stand.dens.sc))
#deviance
shan_170_models
```

averaged model output - averaging all models

```{r message=FALSE, warning=FALSE, include=FALSE}
shan_models_170_avg <- model.avg(shan_170_models)
summary(shan_models_170_avg)
```

```{r}
summary(shan_models_170_avg)$coefmat.subset %>%
  as.data.frame() %>%
  tibble::rownames_to_column(var = "Predictor") %>%
  filter(Predictor != "(Intercept)") %>%  
  rename(Estimate = Estimate, StdError = `Std. Error`) %>%
  mutate(lower95 = Estimate - 1.96 * StdError,
    upper95 = Estimate + 1.96 * StdError,
    lower50 = Estimate - 0.674 * StdError, 
    upper50 = Estimate + 0.674 * StdError) %>%
  ggplot(aes(x = reorder(Predictor, Predictor), y = Estimate)) + 
    geom_errorbar(aes(ymin = lower95, ymax = upper95), width = 0, linewidth = 0.5) +
    geom_errorbar(aes(ymin = lower50, ymax = upper50), width = 0, linewidth = 1.3) +
    geom_point(size = 3) +
    coord_flip() +
    theme_classic() +
    labs(title = "Coefficient Plot - Mammal Diversity (170 ha grid)",
         x = "", y = "coefficient estimate") +
    geom_hline(yintercept = 0, linetype = "dashed", color = "grey50")
```


#### Species eveness model

```{r message=FALSE, warning=FALSE, include=FALSE}
#fitting global model for use in dredge
em_170 <- glm(even.170 ~ 
             mean.tree.h.sc +
             sd.r.sc +
             mean.dbh.sc +
             basal.area.sc + 
             stand.dens.sc +
             stem.vol.sc +
             pts.below.2m.sc +
             zentropy.sc +
             lad.max.sc +
             vFRcanopy.sc +
             vzrumple.sc +
             ClosedGapSpace.sc,
           na.action = na.fail,
           family = Gamma(link = "log"), 
           offset = log.act.days,
           weights = n.scanned,
           data = grid170_mets)

#dredge
even_170_models <- dredge(em_170, m.max = 2, extra = "deviance",
                      subset = !(basal.area.sc && stand.dens.sc))

#deviance
even_170_models
```

averaged model output - averaging all models

```{r message=FALSE, warning=FALSE, include=FALSE}
even_models_170_avg <- model.avg(even_170_models)
summary(even_models_170_avg)
```

```{r}
plot(even_models_170_avg, full = FALSE, intercept = FALSE, main = "Mammal Evenness (170 ha grid) - Av. Mod")
```

#### Functional richness model

```{r message=FALSE, warning=FALSE, include=FALSE}
#fitting global model for use in dredge
fr_170 <- glm(FRich ~ 
             mean.tree.h.sc +
             sd.r.sc +
             mean.dbh.sc +
             basal.area.sc + 
             stand.dens.sc +
             stem.vol.sc +
             pts.below.2m.sc +
             zentropy.sc +
             lad.max.sc +
             vFRcanopy.sc +
             vzrumple.sc +
             ClosedGapSpace.sc,
           na.action = na.fail,
           family = Gamma(link = "log"), 
           offset = log.act.days,
           weights = n.scanned,
           data = grid170_mets)

#dredge
frich_170_models <- dredge(fr_170, m.max = 2, extra = "adjR^2",
                      subset = !(basal.area.sc && stand.dens.sc))
#R-squared information
summary(frich_170_models$`adjR^2`)
```

averaged model output - averaging all models

```{r message=FALSE, warning=FALSE, include=FALSE}
frich_models_170_avg <- model.avg(frich_170_models)
summary(frich_models_170_avg)
```

```{r}
plot(frich_models_170_avg, full = FALSE, intercept = FALSE, main = "Mammal FRich (170 ha grid) - Av. Mod")
```

#### Functional evenness model

```{r message=FALSE, warning=FALSE, include=FALSE}
#fitting global model for use in dredge
fe_170 <- glm(FEven ~ 
             mean.tree.h.sc +
             sd.r.sc +
             mean.dbh.sc +
             basal.area.sc + 
             stand.dens.sc +
             stem.vol.sc +
             pts.below.2m.sc +
             zentropy.sc +
             lad.max.sc +
             vFRcanopy.sc +
             vzrumple.sc +
             ClosedGapSpace.sc,
           na.action = na.fail,
           family = Gamma(link = "log"), 
           offset = log.act.days,
           weights = n.scanned,
           data = grid170_mets)

#dredge
feven_170_models <- dredge(fe_170, m.max = 2, extra = "deviance",
                      subset = !(basal.area.sc && stand.dens.sc)) 

#deviance
feven_170_models
```

averaged model output - averaging all models

```{r message=FALSE, warning=FALSE, include=FALSE}
feven_models_170_avg <- model.avg(feven_170_models)
summary(feven_models_170_avg)
```

```{r}
plot(feven_models_170_avg, full = FALSE, intercept = FALSE, main = "Mammal FEven (170 ha grid) - Av. Mod")
```

#### Functional divergence model

```{r message=FALSE, warning=FALSE, include=FALSE}
#fitting global model for use in dredge
fd_170 <- glm(FDiver ~ 
             mean.tree.h.sc +
             sd.r.sc +
             mean.dbh.sc +
             basal.area.sc + 
             stand.dens.sc +
             stem.vol.sc +
             pts.below.2m.sc +
             zentropy.sc +
             lad.max.sc +
             vFRcanopy.sc +
             vzrumple.sc +
             ClosedGapSpace.sc,
           na.action = na.fail,
           family = Gamma(link = "log"), 
           offset = log.act.days,
           weights = n.scanned,
           data = grid170_mets)

#dredge
fdiver_170_models <- dredge(fd_170, m.max = 2, extra = "deviance",
                      subset = !(basal.area.sc && stand.dens.sc)) 
#deviance
fdiver_170_models
```

averaged model output - averaging all models

```{r message=FALSE, warning=FALSE, include=FALSE}
fdiver_models_170_avg <- model.avg(fdiver_170_models)
summary(fdiver_models_170_avg)
```

```{r}
plot(fdiver_models_170_avg, full = FALSE, intercept = FALSE, main = "Mammal FDiver (170 ha grid) - Av. Mod")
```


#### Comparing coefficient plots from averaged models

Showing only richness, shannon, FEven, and FDiver models, since FRich had convergence issues
```{r fig.height=6, fig.width=6}
#extract coefficients from averaged models
coef_rich <- extract_coefs(rich_models_170_avg, "rich")
coef_shan <- extract_coefs(shan_models_170_avg, "shan")
coef_even <- extract_coefs(even_models_170_avg, "even")
coef_fric <- extract_coefs(frich_models_170_avg, "fric")
coef_feve <- extract_coefs(feven_models_170_avg, "feve")
coef_fdiv <- extract_coefs(fdiver_models_170_avg, "fdiv")

#combine all
coef_df <- rbind(coef_rich, coef_shan, coef_even, coef_fric, coef_feve, coef_fdiv)
rm(coef_rich, coef_shan, coef_even, coef_fric, coef_feve, coef_fdiv)

#specifying order to plot models
coef_df$model <- factor(coef_df$model, levels = rev(c("rich","shan","even","fric","feve","fdiv")))

#select only predictors with 50% CI's that don't overlap zero
coef_df_filter <- coef_df[!(coef_df$`2.5 %` <= 0 & coef_df$`97.5 %` >= 0),]
coef_df_filter <- coef_df_filter[!coef_df_filter$predictor %in% c("(Intercept)", "eigenvectors.sc"),]

#plotting - only the functional models for now
coef_df_filter %>%
  filter(!model %in% c("fric")) %>%
ggplot(aes(x = estimate, y = predictor, color = model)) +
  geom_point(position = position_dodge(width = 0.5), size = 3) +
  geom_errorbar(aes(xmin = `2.5 %`, xmax = `97.5 %`), width = 0, 
                position = position_dodge(width = 0.5)) +
  geom_errorbar(aes(xmin = `25 %`, xmax = `75 %`), width = 0, 
                position = position_dodge(width = 0.5), size = 1.5, linetype = "solid") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "grey50") +
  theme_classic() +
  labs(title = "Reliable Predictors from Avg. 170ha grid Models",
       x = "Coefficient Estimate", y = "") +
  theme(axis.text.y = element_text(hjust = 1),
        legend.position = "bottom") +
  guides(color = guide_legend(reverse = TRUE))
```


### MODELS BY PARTITION

```{r include=FALSE}
#calculating mean of all scaled forest structure metrics
pt_mets <- stand_mets %>%
  group_by(partition) %>%
  dplyr::select(ends_with(".sc")) %>%
  summarize(across(where(is.numeric), mean, na.rm = TRUE))

ct_div_mets_terr <- left_join(ct_div_mets_terr, pt_mets)

#adding ct effort days
ct_div_mets_terr <- ct %>%
  left_join(ct_active_days) %>%
  group_by(partition) %>%
  summarise(effort = sum(act.days, na.rm = TRUE)) %>%
  filter(!partition == "Kerangas") %>%
  left_join(ct_div_mets_terr)

#adding count of scanned locations 
ct_div_mets_terr <- as.data.frame(table(data_sf$partition)) %>%
  rename(partition = Var1,
         n.scanned = Freq) %>%
  left_join(ct_div_mets_terr, ., by = "partition")
```

#### Correlation between metrics
```{r}
df <- ct_div_mets_terr[, c("mean.tree.h.sc", "sd.r.sc", "mean.dbh.sc", "basal.area.sc", "stand.dens.sc", 
                     "stem.vol.sc", "pts.below.2m.sc", "lad.max.sc", "ClosedGapSpace.sc", "vFRcanopy.sc",
                     "zentropy.sc", "vzrumple.sc", "n.terr", "Shannon", "evenness", "FEven", "FDiver")]

colnames(df) <- colnames.list

#corrplot
corr_results <- rcorr(as.matrix(df), type = "spearman")

cor_matrix <- corr_results$r
p_matrix <- corr_results$P 

#save plot
#jpeg("SpearCorrPT.jpg", width = 7, height = 8.5, units = "in", res = 500)

corrplot(cor_matrix,
         method = "color",          
         type = "upper",            
         tl.col = "black",          
         tl.srt = 45,               
         tl.cex = 0.8,              
         cl.pos = "r",              
         addCoef.col = TRUE,
         number.cex = 0.6,
         number.font = 1,
         diag = FALSE)

#dev.off()
```

#### Species richness model

Fitting global model then using {dredge} to find models of best fit
```{r}
#removing MO1 partition since no structure mets are from this pt
ct_div_mets_terr <- ct_div_mets_terr[!ct_div_mets_terr$partition == "MO1",]
```

```{r message=FALSE, warning=FALSE, include=FALSE}
ct_div_mets_terr$log.act.days <- log(ct_div_mets_terr$effort)

#fitting global model for use in dredge
rm_pt1 <- glm(n.terr ~ 
             mean.tree.h.sc +
             sd.r.sc +
             mean.dbh.sc +
             basal.area.sc + 
             stand.dens.sc +
             stem.vol.sc +
             pts.below.2m.sc +
             zentropy.sc +
             lad.max.sc +
             vFRcanopy.sc +
             vzrumple.sc +
             ClosedGapSpace.sc,
           na.action = na.fail,
           family = Gamma(link = "log"), 
           offset = log.act.days,
           weights = n.scanned,
           data = ct_div_mets_terr)

#dredge
rich_pt_models <- dredge(rm_pt1, m.max = 2, extra = "deviance",
                      subset = !(mean.tree.h.sc && vzrumple.sc)) 

#deviance
rich_pt_models
```

averaged model output - averaging all models

```{r message=FALSE, warning=FALSE, include=FALSE}
rich_models_pt_avg <- model.avg(rich_pt_models)
summary(rich_models_pt_avg)
```

```{r}
dev.off()
plot(rich_models_pt_avg, full = FALSE, intercept = FALSE, main = "Mammal Richness (partition) - Av. Mod")
```

#### Species diversity model

Top model summary output.

```{r message=FALSE, warning=FALSE, include=FALSE}
#global model
sm_pt1 <- glm(Shannon ~  
             mean.tree.h.sc +
             sd.r.sc +
             mean.dbh.sc +
             basal.area.sc + 
             stand.dens.sc +
             stem.vol.sc +
             pts.below.2m.sc +
             zentropy.sc +
             lad.max.sc +
             vFRcanopy.sc +
             vzrumple.sc +
             ClosedGapSpace.sc,
           na.action = na.fail,
           family = Gamma(link = "log"), 
           offset = log.act.days,
           weights = n.scanned,
           data = ct_div_mets_terr)
#dredge
shan_pt_models <- dredge(sm_pt1, m.max = 2, extra = "deviance",
                      subset = !(mean.tree.h.sc && vzrumple.sc))
                              
#deviance
shan_pt_models
```

averaged model output - averaging all models

```{r message=FALSE, warning=FALSE, include=FALSE}
#averaging models
shan_models_pt_avg <- model.avg(shan_pt_models)
summary(shan_models_pt_avg)
```

```{r}
summary(shan_models_pt_avg)$coefmat.subset %>%
  as.data.frame() %>%
  tibble::rownames_to_column(var = "Predictor") %>%
  filter(Predictor != "(Intercept)") %>%  
  rename(Estimate = Estimate, StdError = `Std. Error`) %>%
  mutate(lower95 = Estimate - 1.96 * StdError,
    upper95 = Estimate + 1.96 * StdError,
    lower50 = Estimate - 0.674 * StdError, 
    upper50 = Estimate + 0.674 * StdError) %>%
  ggplot(aes(x = reorder(Predictor, Predictor), y = Estimate)) + 
    geom_errorbar(aes(ymin = lower95, ymax = upper95), width = 0, linewidth = 0.5) +
    geom_errorbar(aes(ymin = lower50, ymax = upper50), width = 0, linewidth = 1.3) +
    geom_point(size = 3) +
    coord_flip() +
    theme_classic() +
    labs(title = "Coefficient Plot - Mammal Diversity (partition)",
         x = "", y = "coefficient estimate") +
    geom_hline(yintercept = 0, linetype = "dashed", color = "grey50")
```

#### Species evenness model

Top model summary output.

```{r message=FALSE, warning=FALSE, include=FALSE}
#global model
em_pt1 <- glm(evenness ~  
             mean.tree.h.sc +
             sd.r.sc +
             mean.dbh.sc +
             basal.area.sc + 
             stand.dens.sc +
             stem.vol.sc +
             pts.below.2m.sc +
             zentropy.sc +
             lad.max.sc +
             vFRcanopy.sc +
             vzrumple.sc +
             ClosedGapSpace.sc,
           na.action = na.fail,
           family = Gamma(link = "log"), 
           offset = log.act.days,
           weights = n.scanned,
           data = ct_div_mets_terr)
#dredge
even_pt_models <- dredge(em_pt1, m.max = 2, extra = "deviance",
                      subset = !(mean.tree.h.sc && vzrumple.sc)) 

#deviance
even_pt_models
```

averaged model output - averaging all models

```{r message=FALSE, warning=FALSE, include=FALSE}
even_models_pt_avg <- model.avg(even_pt_models)
summary(even_models_pt_avg)
```

```{r}
plot(even_models_pt_avg, full = FALSE, intercept = FALSE, 
     main = "Terrestrial Mammal Evenness (partition) - Av. Mod")
```


#### Functional richness model

Convergence issues
```{r message=FALSE, warning=FALSE, include=FALSE}
#global model
frich_pt <- glm(FRich ~  
             mean.tree.h.sc +
             sd.r.sc +
             mean.dbh.sc +
             basal.area.sc + 
             stand.dens.sc +
             stem.vol.sc +
             pts.below.2m.sc +
             zentropy.sc +
             lad.max.sc +
             vFRcanopy.sc +
             vzrumple.sc +
             ClosedGapSpace.sc,
           na.action = na.fail,
           family = Gamma(link = "log"), 
           offset = log.act.days,
           weights = n.scanned,
           data = ct_div_mets_terr)
#dredge
frich_pt_models <- dredge(frich_pt, m.max = 2, extra = "adjR^2",
                      subset = !(mean.tree.h.sc && vzrumple.sc)) 

#R-squared information
summary(frich_pt_models)
```

averaged model output - averaging all models

```{r message=FALSE, warning=FALSE, include=FALSE}
frich_pt_models_avg <- model.avg(frich_pt_models)
summary(frich_pt_models_avg)
```

```{r}
plot(frich_pt_models_avg, full = FALSE, intercept = FALSE, 
     main = "Functional Richness (partition) - Av. Mod")
```


#### Functional evenness model

Top model summary output.

```{r message=FALSE, warning=FALSE, include=FALSE}
#global model
feven_pt <- glm(FEven ~  
             mean.tree.h.sc +
             sd.r.sc +
             mean.dbh.sc +
             basal.area.sc + 
             stand.dens.sc +
             stem.vol.sc +
             pts.below.2m.sc +
             zentropy.sc +
             lad.max.sc +
             vFRcanopy.sc +
             vzrumple.sc +
             ClosedGapSpace.sc,
           na.action = na.fail,
           family = Gamma(link = "log"), 
           offset = log.act.days,
           weights = n.scanned,
           data = ct_div_mets_terr)
#dredge
feven_pt_models <- dredge(feven_pt, m.max = 2, extra = "deviance",
                      subset = !(mean.tree.h.sc && vzrumple.sc))

#deviance
feven_pt_models
```

averaged model output - averaging all models

```{r message=FALSE, warning=FALSE, include=FALSE}
feven_pt_models_avg <- model.avg(feven_pt_models)
summary(feven_pt_models_avg)
```

```{r}
plot(feven_pt_models_avg, full = FALSE, intercept = FALSE, 
     main = "Functional Evenness (partition) - Av. Mod")
```


#### Functional divergence model

Top model summary output.

```{r message=FALSE, warning=FALSE, include=FALSE}
#global model
fdiver_pt <- glm(FDiver ~  
             mean.tree.h.sc +
             sd.r.sc +
             mean.dbh.sc +
             basal.area.sc + 
             stand.dens.sc +
             stem.vol.sc +
             pts.below.2m.sc +
             zentropy.sc +
             lad.max.sc +
             vFRcanopy.sc +
             vzrumple.sc +
             ClosedGapSpace.sc,
           na.action = na.fail,
           family = Gamma(link = "log"), 
           offset = log.act.days,
           weights = n.scanned,
           data = ct_div_mets_terr)
#dredge
fdiver_pt_models <- dredge(fdiver_pt, m.max = 2,  extra = "deviance",
                      subset = !(mean.tree.h.sc && vzrumple.sc))

#deviance
fdiver_pt_models
```

averaged model output - averaging all models

```{r message=FALSE, warning=FALSE, include=FALSE}
fdiver_pt_models_avg <- model.avg(fdiver_pt_models)
summary(fdiver_pt_models_avg)
```

```{r}
plot(fdiver_pt_models_avg, full = FALSE, intercept = FALSE, 
     main = "Functional Divergence (partition) - Av. Mod")
```


#### Comparing coefficient plot from averaged models

```{r fig.height=5, fig.width=6}
#extract coefficients for each averaged model
coef_rich <- extract_coefs(rich_models_pt_avg, "rich")
coef_shan <- extract_coefs(shan_models_pt_avg, "shan")
coef_even <- extract_coefs(even_models_pt_avg, "even")
coef_fric <- extract_coefs(frich_pt_models_avg, "fric")
coef_feve <- extract_coefs(feven_pt_models_avg, "feve")
coef_fdiv <- extract_coefs(fdiver_pt_models_avg, "fdiv")

#combine all
coef_pt_df <- rbind(coef_rich, coef_shan, coef_even, coef_fric, coef_feve, coef_fdiv)
rm(coef_rich, coef_shan, coef_even, coef_fric, coef_feve, coef_fdiv)

#specifying order to plot models
coef_pt_df$model <- factor(coef_pt_df$model, levels = rev(c("rich","shan","even","fric","feve","fdiv")))

#select only predictors with CI's that don't overlap zero
coef_pt_df_filter <- coef_pt_df[!(coef_pt_df$`2.5 %` <= 0 & coef_pt_df$`97.5 %` >= 0),]
coef_pt_df_filter <- coef_pt_df_filter[coef_pt_df_filter$predictor != "(Intercept)",]

#plotting
coef_pt_df_filter %>%
  filter(!model %in% c("fric")) %>%
ggplot(aes(x = estimate, y = predictor, color = model)) +
  geom_point(position = position_dodge(width = 0.5), size = 3) +
  geom_errorbar(aes(xmin = `2.5 %`, xmax = `97.5 %`), width = 0, 
                position = position_dodge(width = 0.5)) +
  geom_errorbar(aes(xmin = `25 %`, xmax = `75 %`), width = 0, 
                position = position_dodge(width = 0.5), size = 1.5, linetype = "solid") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "grey50") +
  theme_classic() +
  labs(title = "Reliable Predictors from Averaged Partition Models",
       x = "Coefficient Estimate", y = "") +
  theme(axis.text.y = element_text(hjust = 1),
        legend.position = "bottom") +
  guides(color = guide_legend(reverse = TRUE)) +
  scale_y_discrete(labels = c("vFRcanopy.sc" = "veg. vol.",
                              "rumple.sc" = "rumple index"))
```

### Comparing effects of scale by outcome variable

```{r}
#setting global label mapping for forest structure metrics
label_mappings <- c("mean.tree.h.sc" = "tree h mean",
                    "rumple.sc" = "rumple index",
                    "zentropy.sc" = "vertical point\ndistribution",
                    "lad.max.sc" = "leaf area\ndensity",
                    "CRR.rho.sc" = "canopy\nrelief ratio",
                    "ClosedGapSpace.sc" = "gap volume",
                    "vFRcanopy.sc" = "vegetation\nvolume",
                    "sd.r.sc" = "tree h sd",
                    "max.height.sc" = "tree h max.",
                    "stem.vol.sc" = "tree volume",
                    "mean.dbh.sc" = "tree dbh",
                    "vzrumple.sc" = "vertical point\ncomplexity",
                    "stand.dens.sc" = "tree density",
                    "basal.area.sc" = "basal area",
                    "pts.below.2m.sc" = "near-ground\nvegetation")

#setting order
metrics_order <- c("mean.tree.h.sc", "sd.r.sc", "mean.dbh.sc", "basal.area.sc",
                   "stand.dens.sc", "stem.vol.sc", "pts.below.2m.sc", "lad.max.sc",
                   "ClosedGapSpace.sc", "vFRcanopy.sc", "zentropy.sc", "vzrumple.sc")
```


#### Species richness

```{r eval=FALSE, fig.height=9, fig.width=6, include=FALSE}
#extract coefficients from averaged models
coef_rich_ct <- extract_coefs(rich_models_avg, "rich")
coef_rich_ct$model <- "rich_ct"
coef_rich_75 <- extract_coefs(rich_models_75_avg, "rich")
coef_rich_75$model <- "rich_75"
coef_rich_170 <- extract_coefs(rich_models_170_avg, "rich")
coef_rich_170$model <- "rich_170"
coef_rich_pt <- extract_coefs(rich_models_pt_avg, "rich")
coef_rich_pt$model <- "rich_pt"

#combine all
coef_df <- rbind(coef_rich_ct, coef_rich_75, coef_rich_170, coef_rich_pt)
rm(coef_rich_ct, coef_rich_75, coef_rich_170, coef_rich_pt)

#specifying order to plot models
coef_df$model <- factor(coef_df$model, levels = rev(c("rich_ct","rich_pt","rich_75","rich_170")))

#select only predictors with 50% CI's that don't overlap zero
#coef_df_filter <- coef_df[!(coef_df$`25 %` <= 0 & coef_df$`75 %` >= 0),]
coef_df <- coef_df[!coef_df$predictor %in% c("(Intercept)", "eigenvectors.sc"),]

#plotting - only the functional models for now
ggplot(coef_df, aes(x = estimate, y = factor(predictor, levels = rev(metrics_order)), color = model)) +
  geom_point(position = position_dodge(width = 0.5), size = 3) +
  geom_errorbar(aes(xmin = `2.5 %`, xmax = `97.5 %`), width = 0, 
                position = position_dodge(width = 0.5)) +
  geom_errorbar(aes(xmin = `25 %`, xmax = `75 %`), width = 0, 
                position = position_dodge(width = 0.5), size = 1.5, linetype = "solid") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "grey50") +
  theme_classic() +
  labs(title = "",
       x = "coefficient estimate", y = "", color = "scale:") +
  theme(axis.text.y = element_text(hjust = 1),
        legend.position = "bottom") +
  guides(color = guide_legend(reverse = TRUE)) +
  scale_y_discrete(labels = label_mappings) +
  scale_color_manual(values = rev(c("forestgreen", "darkgreen", "grey", "steelblue")),
                     labels = rev(c("camera trap",
                                  "forest type partition", 
                                      expression("grid: 0.75 km"^2), 
                                      expression("grid: 1.7 km"^2))))

#ggsave("rich_multiplot2.jpg", plot = last_plot(), width = 7, height = 8.5, dpi = 500, device = "jpeg")
```

#### Shannon diversity

```{r fig.height=9, fig.width=6}
#extract coefficients from averaged models
coef_shan_ct <- extract_coefs(shan_models_avg, "shan")
coef_shan_ct$model <- "shan_ct"
coef_shan_75 <- extract_coefs(shan_models_75_avg, "shan")
coef_shan_75$model <- "shan_75"
coef_shan_170 <- extract_coefs(shan_models_170_avg, "shan")
coef_shan_170$model <- "shan_170"
coef_shan_pt <- extract_coefs(shan_models_pt_avg, "shan")
coef_shan_pt$model <- "shan_pt"

#combine all
coef_df <- rbind(coef_shan_ct, coef_shan_75, coef_shan_170, coef_shan_pt)
rm(coef_shan_ct, coef_shan_75, coef_shan_170, coef_shan_pt)

#specifying order to plot models
coef_df$model <- factor(coef_df$model, levels = rev(c("shan_ct","shan_pt","shan_75","shan_170")))

#select only predictors with 50% CI's that don't overlap zero
#coef_df_filter <- coef_df[!(coef_df$`25 %` <= 0 & coef_df$`75 %` >= 0),]
coef_df <- coef_df[!coef_df$predictor %in% c("(Intercept)", "eigenvectors.sc"),]

#plotting 
ggplot(coef_df, aes(x = estimate, y = factor(predictor, levels = rev(metrics_order)), color = model)) +
  geom_point(position = position_dodge(width = 0.5), size = 3) +
  geom_errorbar(aes(xmin = `2.5 %`, xmax = `97.5 %`), width = 0, 
                position = position_dodge(width = 0.5)) +
  geom_errorbar(aes(xmin = `25 %`, xmax = `75 %`), width = 0, 
                position = position_dodge(width = 0.5), size = 1.5, linetype = "solid") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "grey50") +
  theme_classic() +
  labs(title = "",
       x = "coefficient estimate", y = "", color = "scale:") +
  theme(axis.text.y = element_text(hjust = 1), legend.position = "bottom",
        legend.text = element_text(size = 9)) +
  guides(color = guide_legend(reverse = TRUE)) +
  coord_cartesian(xlim = c(-3, 2.6)) +
  scale_color_manual(values = rev(c("forestgreen", "darkgreen", "grey", "steelblue")),
                     labels = rev(c("camera trap",
                                  "forest type partition", 
                                      expression("grid: 0.75 km"^2), 
                                      expression("grid: 1.7 km"^2)))) +
  scale_y_discrete(labels = label_mappings)

#ggsave("shan_multiplot.jpg", plot = last_plot(), width = 7, height = 8.5, dpi = 500, device = "jpeg")
```

#### Species evenness

```{r eval=FALSE, fig.height=9, fig.width=6, include=FALSE}
#extract coefficients from averaged models
coef_even_ct <- extract_coefs(even_models_avg, "even")
coef_even_ct$model <- "even_ct"
coef_even_75 <- extract_coefs(even_models_75_avg, "even")
coef_even_75$model <- "even_75"
coef_even_170 <- extract_coefs(even_models_170_avg, "even")
coef_even_170$model <- "even_170"
coef_even_pt <- extract_coefs(even_models_pt_avg, "even")
coef_even_pt$model <- "even_pt"

#combine all
coef_df <- rbind(coef_even_ct, coef_even_75, coef_even_170, coef_even_pt)
rm(coef_even_ct, coef_even_75, coef_even_170, coef_even_pt)

#specifying order to plot models
coef_df$model <- factor(coef_df$model, levels = rev(c("even_ct","even_pt","even_75","even_170")))

#select only predictors with 50% CI's that don't overlap zero
#coef_df_filter <- coef_df[!(coef_df$`25 %` <= 0 & coef_df$`75 %` >= 0),]
coef_df <- coef_df[!coef_df$predictor %in% c("(Intercept)", "eigenvectors.sc"),]

#plotting - only the functional models for now
ggplot(coef_df, aes(x = estimate, y = factor(predictor, levels = rev(metrics_order)), color = model)) +
  geom_point(position = position_dodge(width = 0.5), size = 3) +
  geom_errorbar(aes(xmin = `2.5 %`, xmax = `97.5 %`), width = 0, 
                position = position_dodge(width = 0.5)) +
  geom_errorbar(aes(xmin = `25 %`, xmax = `75 %`), width = 0, 
                position = position_dodge(width = 0.5), size = 1.5, linetype = "solid") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "grey50") +
  theme_classic() +
  labs(title = "",
       x = "coefficient estimate", y = "", color = "scale:") +
  theme(axis.text.y = element_text(hjust = 1),
        legend.position = "bottom") +
  guides(color = guide_legend(reverse = TRUE)) +
  scale_y_discrete(labels = label_mappings) +
  scale_color_manual(values = rev(c("forestgreen", "darkgreen", "grey", "steelblue")),
                     labels = rev(c("camera trap",
                                  "forest type partition", 
                                      expression("grid: 0.75 km"^2), 
                                      expression("grid: 1.7 km"^2))))

#ggsave("even_multiplot.jpg", plot = last_plot(), width = 7.5, height = 9.5, dpi = 500, device = "jpeg")
```

#### Functional evenness

```{r eval=FALSE, fig.height=9, fig.width=6, include=FALSE}
#extract coefficients from averaged models
coef_Feve_ct <- extract_coefs(feven_models_avg, "feve")
coef_Feve_ct$model <- "Feve_ct"
coef_Feve_75 <- extract_coefs(feven_models_75_avg, "feve")
coef_Feve_75$model <- "Feve_75"
coef_Feve_170 <- extract_coefs(feven_models_170_avg, "feve")
coef_Feve_170$model <- "Feve_170"
coef_Feve_pt <- extract_coefs(feven_pt_models_avg, "feve")
coef_Feve_pt$model <- "Feve_pt"

#combine all
coef_df <- rbind(coef_Feve_ct, coef_Feve_75, coef_Feve_170, coef_Feve_pt)
rm(coef_Feve_ct, coef_Feve_75, coef_Feve_170, coef_Feve_pt)

#specifying order to plot models
coef_df$model <- factor(coef_df$model, levels = rev(c("Feve_ct","Feve_pt","Feve_75","Feve_170")))

#select only predictors with 50% CI's that don't overlap zero
#coef_df_filter <- coef_df[!(coef_df$`25 %` <= 0 & coef_df$`75 %` >= 0),]
coef_df <- coef_df[!coef_df$predictor %in% c("(Intercept)", "eigenvectors.sc"),]

#plotting
ggplot(coef_df, aes(x = estimate, y = factor(predictor, levels = rev(metrics_order)), color = model)) +
  geom_point(position = position_dodge(width = 0.5), size = 3) +
  geom_errorbar(aes(xmin = `2.5 %`, xmax = `97.5 %`), width = 0, 
                position = position_dodge(width = 0.5)) +
  geom_errorbar(aes(xmin = `25 %`, xmax = `75 %`), width = 0, 
                position = position_dodge(width = 0.5), size = 1.5, linetype = "solid") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "grey50") +
  theme_classic() +
  labs(title = "",
       x = "coefficient estimate", y = "", color = "scale:") +
  theme(axis.text.y = element_text(hjust = 1),
        legend.position = "bottom") +
  guides(color = guide_legend(reverse = TRUE)) +
  scale_y_discrete(labels = label_mappings) +
  scale_color_manual(values = rev(c("forestgreen", "darkgreen", "grey", "steelblue")),
                     labels = rev(c("camera trap",
                                  "forest type partition", 
                                      expression("grid: 0.75 km"^2), 
                                      expression("grid: 1.7 km"^2))))

#ggsave("feve_multiplot.jpg", plot = last_plot(), width = 7.5, height = 9.5, dpi = 500, device = "jpeg")
```

#### Functional divergence

```{r eval=FALSE, fig.height=9, fig.width=6, include=FALSE}
#extract coefficients from averaged models
coef_Fdiv_ct <- extract_coefs(fdiver_models_avg, "fdiv")
coef_Fdiv_ct$model <- "Fdiv_ct"
coef_Fdiv_75 <- extract_coefs(fdiver_models_75_avg, "fdiv")
coef_Fdiv_75$model <- "Fdiv_75"
coef_Fdiv_170 <- extract_coefs(fdiver_models_170_avg, "fdiv")
coef_Fdiv_170$model <- "Fdiv_170"
coef_Fdiv_pt <- extract_coefs(fdiver_pt_models_avg, "fdiv")
coef_Fdiv_pt$model <- "Fdiv_pt"

#combine all
coef_df <- rbind(coef_Fdiv_ct, coef_Fdiv_75, coef_Fdiv_170, coef_Fdiv_pt)
rm(coef_Fdiv_ct, coef_Fdiv_75, coef_Fdiv_170, coef_Fdiv_pt)

#specifying order to plot models
coef_df$model <- factor(coef_df$model, levels = rev(c("Fdiv_ct","Fdiv_pt","Fdiv_75","Fdiv_170")))

#select only predictors with 50% CI's that don't overlap zero
#coef_df_filter <- coef_df[!(coef_df$`25 %` <= 0 & coef_df$`75 %` >= 0),]
coef_df <- coef_df[!coef_df$predictor %in% c("(Intercept)", "eigenvectors.sc"),]

#plotting 
ggplot(coef_df, aes(x = estimate, y = factor(predictor, levels = rev(metrics_order)), color = model)) +
  geom_point(position = position_dodge(width = 0.5), size = 3) +
  geom_errorbar(aes(xmin = `2.5 %`, xmax = `97.5 %`), width = 0, 
                position = position_dodge(width = 0.5)) +
  geom_errorbar(aes(xmin = `25 %`, xmax = `75 %`), width = 0, 
                position = position_dodge(width = 0.5), size = 1.5, linetype = "solid") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "grey50") +
  theme_classic() +
  labs(title = "",
       x = "coefficient estimate", y = "", color = "model scale:") +
  theme(axis.text.y = element_text(hjust = 1),
        legend.position = "bottom") +
  guides(color = guide_legend(reverse = TRUE)) +
  scale_y_discrete(labels = label_mappings) +
  scale_color_manual(values = rev(c("forestgreen", "darkgreen", "grey", "steelblue")),
                     labels = rev(c("camera trap",
                                  "forest type partition", 
                                      expression("grid: 0.75 km"^2), 
                                      expression("grid: 1.7 km"^2))))

#ggsave("fdiv_multiplot.jpg", plot = last_plot(), width = 7.5, height = 9.5, dpi = 500, device = "jpeg")
```

#### Model comparison

Cross-validation
Uses mean square error (MSE) to compare predictive performance (i.e., fits the data more robustly and generalizes better to new samples)
```{r}
library(boot)

#partition models
cv.glm(data = ct_div_mets_terr, glmfit = get.models(rich_pt_models, 1)[[1]], K = 11)$delta[[2]]   #60.8
cv.glm(data = ct_div_mets_terr, glmfit = get.models(shan_pt_models, 1)[[1]], K = 11)$delta[[2]]   #1.10
cv.glm(data = ct_div_mets_terr, glmfit = get.models(even_pt_models, 1)[[1]], K = 11)$delta[[2]]   #0.086
cv.glm(data = ct_div_mets_terr, glmfit = get.models(fdiver_pt_models, 1)[[1]], K = 11)$delta[[2]] #0.176
cv.glm(data = ct_div_mets_terr, glmfit = get.models(feven_pt_models, 1)[[1]], K = 11)$delta[[2]]  #0.038

#grid models
cv.glm(data = grid170_mets, glmfit = get.models(rich_170_models, 1)[[1]], K = 10)$delta[[2]]   #247.6
cv.glm(data = grid170_mets, glmfit = get.models(shan_170_models, 1)[[1]], K = 10)$delta[[2]]   #1.89
cv.glm(data = grid170_mets, glmfit = get.models(even_170_models, 1)[[1]], K = 10)$delta[[2]]   #0.198
cv.glm(data = grid170_mets, glmfit = get.models(fdiver_170_models, 1)[[1]], K = 10)$delta[[2]] #0.420
cv.glm(data = grid170_mets, glmfit = get.models(feven_170_models, 1)[[1]], K = 10)$delta[[2]]  #0.132
```

Comparing deviance across top models

partition model deviance ranges from 2.08 - 5.96, compared to 6.51 - 10.6 for the grid models
```{r}
#partition models
get.models(rich_pt_models, 1)[[1]] #deviance = 2.08, wt = 1
get.models(shan_pt_models, 1)[[1]] #deviance = 4.97 (5.22, n=2), wt = 0.859
get.models(even_pt_models, 1)[[1]] #deviance = 5.96 (6.28, n=9), wt = 0.453
get.models(fdiver_pt_models, 1)[[1]] #deviance = 4.27 (4.52, n=4), wt = 0.649
get.models(feven_pt_models, 1)[[1]] #deviance = 3.81 (3.85, n=2), wt = 0.625

get.models(rich_170_models, 1)[[1]] #deviance = 6.85, wt = 1
get.models(shan_170_models, 1)[[1]] #deviance = 7.49, wt = 1
get.models(even_170_models, 1)[[1]] #deviance = 8.15, wt = 1
get.models(fdiver_170_models, 1)[[1]] #deviance = 8.56, wt = 1
get.models(feven_170_models, 1)[[1]] #deviance = 10.62, wt = 1
```


Comparing top model output
```{r}
#function to return top model details
extract_top_model <- function(dredge_obj, model_name) {
  top_model <- get.models(dredge_obj, subset = 1)[[1]]
  predictors <- names(coef(top_model))[-1] # exclude intercept
  weight <- dredge_obj$weight[1]
  data.frame(
    Model = model_name,
    Predictors = paste(predictors, collapse = ", "),
    Weight = weight
  )
}

#create model list
model_list <- list(
  Rich_170 = rich_170_models,
  Shan_170 = shan_170_models,
  Even_170 = even_170_models,
  FEven_170 = feven_170_models,
  FDiver_170 = fdiver_170_models,
  Rich_pt = rich_pt_models,
  Shan_pt = shan_pt_models,
  Even_pt = even_pt_models,
  FEven_pt = feven_pt_models,
  FDiver_pt = fdiver_170_models)

top_model_summary <- imap_dfr(model_list, extract_top_model)

top_model_summary

#write.csv(top_model_summary, file = "TopModelSummary.csv")
```


Marginal effects plots from top models
```{r}
### Tree density
#ct - FEven
cp1 <- ggpredict(get.models(feven_models, 1)[[1]], terms = "stand.dens.sc") %>%
  ggplot(aes(x = x, y = predicted)) +
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high), fill = "lightgreen", alpha = 0.3) +
  geom_line(color = "forestgreen", size = 1.2) +
  theme_classic() +
  labs(x = "trees/ha (z)", y = "predicted functional evenness", title = "tree density\n(camera trap)") +
  theme(plot.title = element_text(hjust = 0.5)) +
  ylim(0, 1.7)

### Basal area
#ct - Feven
cp2 <- ggpredict(get.models(feven_models, 2)[[1]], terms = "basal.area.sc") %>%
  ggplot(aes(x = x, y = predicted)) +
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high), fill = "lightgreen", alpha = 0.3) +
  geom_line(color = "forestgreen", size = 1.2) +
  theme_classic() +
  labs(x = "m²/ha (z)", y = "", title = "basal area\n(camera trap)") +
  theme(plot.title = element_text(hjust = 0.5)) +
  ylim(0, 1.7)

### Gap volume
#ct scale - richness
cp3 <- ggpredict(get.models(rich_models, 2)[[1]], terms = "ClosedGapSpace.sc") %>%
  ggplot(aes(x = x, y = predicted)) +
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high), fill = "lightgreen", alpha = 0.3) +
  geom_line(color = "forestgreen", size = 1.2) +
  theme_classic() +
  labs(x = "m³ (z)", y = "predicted species richness", title = "gap volume\n(camera trap)") +
  theme(plot.title = element_text(hjust = 0.5)) +
  xlim(-1, 1) + ylim(0, 68)

### Veg vol
#ct scale - richness
cp4 <- ggpredict(get.models(rich_models, 1)[[1]], terms = "vFRcanopy.sc") %>%
  ggplot(aes(x = x, y = predicted)) +
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high), fill = "lightgreen", alpha = 0.3) +
  geom_line(color = "forestgreen", size = 1.2) +
  theme_classic() +
  labs(x = "m³ (z)", y = "predicted species richness", title = "veg. vol.\n(camera trap)") +
  theme(plot.title = element_text(hjust = 0.5)) +
  ylim(0, 68)

#pt scale - richness
cp5 <- ggpredict(get.models(rich_pt_models, 1)[[1]], terms = "vFRcanopy.sc") %>%
  ggplot(aes(x = x, y = predicted)) +
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high), fill = "green", alpha = 0.3) +
  geom_line(color = "darkgreen", size = 1.2) +
  theme_classic() +
  labs(x = "m³ (z)", y = "", title = "veg. vol.\n(partition)") +
  theme(plot.title = element_text(hjust = 0.5)) +
  ylim(0, 68)

### Tree dbh
#75 grid - richness
cp6 <- ggpredict(get.models(rich_75_models, 1)[[1]], terms = "mean.dbh.sc") %>%
  ggplot(aes(x = x, y = predicted)) +
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high), fill = "lightgrey", alpha = 0.3) +
  geom_line(color = "grey", size = 1.2) +
  theme_classic() +
  labs(x = "cm (z)", y = "", title = "tree dbh\n(0.75 km² grid)") +
  theme(plot.title = element_text(hjust = 0.5)) +
  ylim(0, 68)

### Mean tree height
#0.75 scale
cp7 <- ggpredict(get.models(rich_75_models, 1)[[1]], terms = "mean.tree.h.sc") %>%
  ggplot(aes(x = x, y = predicted)) +
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high), fill = "lightgrey", alpha = 0.3) +
  geom_line(color = "grey", size = 1.2) +
  theme_classic() +
  labs(x = "m (z)", y = "predicted species richness", title = "tree h mean\n(0.75 km² grid)") +
  theme(plot.title = element_text(hjust = 0.5)) +
  ylim(0, 68)

#1.7 scale
cp8 <- ggpredict(get.models(rich_170_models, 1)[[1]], terms = "mean.tree.h.sc") %>%
  ggplot(aes(x = x, y = predicted)) +
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high), fill = "lightblue", alpha = 0.3) +
  geom_line(color = "steelblue", size = 1.2) +
  theme_classic() +
  labs(x = "m (z)", y = "", title = "tree h mean\n(1.7 km² grid)") +
  theme(plot.title = element_text(hjust = 0.5)) + 
  coord_cartesian(ylim = c(0, 68), xlim = c(-0.6, 0.6))

### Vertical complex.
#170 grid - richness
cp9 <- ggpredict(get.models(rich_170_models, 1)[[1]], terms = "vzrumple.sc") %>%
  ggplot(aes(x = x, y = predicted)) +
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high), fill = "lightblue", alpha = 0.3) +
  geom_line(color = "steelblue", size = 1.2) +
  theme_classic() +
  labs(x = "vert. rumple (z)", y = "", title = "vertical pt. complex.\n(1.7 km² grid)") +
  theme(plot.title = element_text(hjust = 0.5)) +
  coord_cartesian(ylim = c(0, 68))
```

```{r}
#create dummy data for legend
legend_df <- data.frame(
  x = rep(c(1, 2), 4),
  y = rep(1:4, each = 2),
  scale = factor(rep(c("camera trap", "partition", "grid: 0.75 km²", "grid: 1.7 km²"), each = 2),
                 levels = c("camera trap", "partition", "grid: 0.75 km²", "grid: 1.7 km²")))

#dummy plot
legend_plot <- ggplot(legend_df, aes(x = x, y = y, color = scale, group = scale)) +
  geom_line(size = 1.5) +
  scale_color_manual(values = c(
    "camera trap" = "forestgreen",
    "partition" = "darkgreen",
    "grid: 0.75 km²" = "grey",
    "grid: 1.7 km²" = "steelblue")) +
  theme_void() +
  theme(legend.position = "bottom")

#extract legend
g <- ggplotGrob(legend_plot)
guide_index <- which(sapply(g$grobs, function(x) x$name) == "guide-box")
legend <- g$grobs[[guide_index]]

#plot marginal effects multiplot
cowplot::plot_grid(
  cowplot::plot_grid(cp1, cp2, cp3, cp4, cp5, cp6, cp7, cp8, cp9, nrow = 3),
  legend, ncol = 1, rel_heights = c(1, 0.08))

#ggsave("ME_multi.jpg", plot = last_plot(), width = 7.5, height = 8, dpi = 500, device = "jpeg")
```




## Spatial heterogeneity in the grid systems compared to partitions

How do forest types and partitions map on to the grid systems?

```{r}
#read in the forest type and partitions by grid cell data
grid_int <- read.csv(file = "data/grids_intersect.csv", header = TRUE)

#remove heath forests
grid_int <- grid_int[!grid_int$habitat == "Heath",]

#number and avg. of partitions in each cell of the two grid systems
table(grid_int$grid_id[grid_int$grid_size == 75])
mean(table(grid_int$grid_id[grid_int$grid_size == 75]))

table(grid_int$grid_id[grid_int$grid_size == 170])
mean(table(grid_int$grid_id[grid_int$grid_size == 170]))
```

What proportion of partitions are within each cell of the two grid systems?
```{r}
#calculate partition proportions
grid_int <- grid_int %>%
  group_by(grid_size, grid_id) %>%
  mutate(prop = Shape_Area / sum(Shape_Area))

#ordering partitions
grid_int$partition <- factor(grid_int$partition, levels = rev(c("PS1", "FS1", "AB1", "AB2",
                                          "LS1", "LS2","LG1","LG2", "UG1","UG2", "MO1", "MO2")),
                    ordered = TRUE)

#setting custom colors that match the forest type map
partition_colors <- c("PS1" = "#401D00", 
                      "FS1" = "#643E00", 
                      "AB1" = "#896007", 
                      "AB2" = alpha("#896007", 0.7),
                      "LS1" = "#AF8228", 
                      "LS2" = alpha("#AF8228", 0.7), 
                      "LG1" = "#D3A43B", 
                      "LG2" = alpha("#D3A43B", 0.7), 
                      "UG1" = "#F4C444",
                      "UG2" = alpha("#F4C444", 0.7), 
                      "MO1" = "#FFDD2D", 
                      "MO2" = alpha("#FFDD2D", 0.7))

#plot for 75 ha grid
p1 <- ggplot(grid_int[grid_int$grid_size == 75,],
       aes(x = factor(grid_id), y = prop, fill = partition)) +
  geom_bar(stat = "identity") +
  labs(title = expression("0.75 km"^2*"grid scale"), 
       x = "grid cell ID", y = "proportion of forest type partition", 
       fill = "partition") +
  theme_classic() +
  coord_flip() +
  scale_fill_manual(values = partition_colors) +
  theme(legend.position = "none",
        plot.title = element_text(hjust = 0.5))

#plot for 170 ha grid
p2 <- ggplot(grid_int[grid_int$grid_size == 170,],
       aes(x = factor(grid_id), y = prop, fill = partition)) +
  geom_bar(stat = "identity") +
  labs(title = expression("1.7 km"^2*"grid scale"), 
       x = "", y = "proportion of forest type partition", 
       fill = "partition") +
  theme_classic() +
  coord_flip() +
  scale_fill_manual(values = partition_colors) +
  theme(plot.title = element_text(hjust = 0.5))

cowplot::plot_grid(p1, p2,nrow = 1, rel_widths = c(.4, .55))

#ggsave("spatial_hetero.jpg", plot = last_plot(), width = 7.5, height = 6, dpi = 500, device = "jpeg")
```


How does variation in structure metrics compare between scales?
```{r}
metric_list2 <- sub("\\.sc$", "", metrics_order)
metric_list_FD <- c(metric_list, metric_list2, "FRich", "FEven", "FDiver")
stand_mets$study.area <- 1

#function to calculate adjusted coefficient of variation
calculate_adj_cv <- function(x) {
  N <- length(x[!is.na(x)])
  if (N > 1) {
    mean_x <- mean(x, na.rm = TRUE)
    sd_x <- sd(x, na.rm = TRUE)
    adj_cv <- (1 + 1 / (4 * N)) * (sd_x / mean_x)
    return(adj_cv)
  } else {
    return(NA)
  }
}

summarize_adj_cv <- function(data, scale_column) {
  data %>%
    group_by(!!sym(scale_column)) %>%
    summarize(across(all_of(metric_list_FD), ~ calculate_adj_cv(.x))) %>%
    summarize(across(all_of(metric_list_FD), list(mean_adj_cv = ~ mean(.x, na.rm = TRUE))))
}

#calculate adj CV summary stats for each scale and entire study area
summary_75ha <- summarize_adj_cv(stand_mets, "grid75")
summary_170ha <- summarize_adj_cv(stand_mets, "grid170")
summary_650ha <- summarize_adj_cv(stand_mets, "grid650")
summary_partition <- stand_mets %>%
  mutate(across(c("grid75", "grid170", "grid650", "partition"), as.numeric)) %>%
  summarize_adj_cv(., "partition")
summary_all <- summarize_adj_cv(stand_mets, "study.area")


#combine
adjCV_mets <- bind_rows(summary_75ha %>% mutate(scale = "75 ha"),
  summary_170ha %>% mutate(scale = "170 ha"),
  summary_650ha %>% mutate(scale = "650 ha"),
  summary_partition %>% mutate(scale = "partition"),
  summary_all %>% mutate(scale = "study area")) %>%
  pivot_longer(cols = -scale, names_to = "metric_stat", values_to = "value") %>%
  separate(metric_stat, into = c("metric", "stat"), sep = "_mean") %>%
  pivot_wider(names_from = scale, values_from = value) %>%
  mutate("pt<170ha" = partition < `170 ha`,
         "75<170" = `75 ha` < `170 ha`,
         "170<650" = `170 ha` < `650 ha`,
         "650<SA" = `650 ha` < `study area`,
         "75<SA" = `75 ha` < `study area`) %>%
  print(n = Inf)
```


Figure showing how average adjusted coefficient of variation (which controls for number of camera trap locations in each cell) increases as grid size increases across the 15 forest structure metrics.
```{r fig.height=7, fig.width=5}
adjCV_mets %>%
  filter(!metric %in% c("n.all", "shannon_ct", "div_even", "FRich", "FEven", "FDiver")) %>%
  pivot_longer(cols = c(`75 ha`, `170 ha`, `650 ha`, `study area`), 
               names_to = "scale", values_to = "value") %>%
  mutate(scale = factor(scale, 
                        levels = c("75 ha", "170 ha", "650 ha", "study area")),
         metric_label = recode(metric, 
                              "mean.tree.h" = "tree h",
                              "rumple" = "rumple",
                              "zentropy" = "vert. dist.",
                              "lad.max" = "LAD",
                              "CRR.rho" = "CRR",
                              "ClosedGapSpace" = "gap vol.",
                              "vFRcanopy" = "veg. vol.",
                              "sd.r" = "tree h sd",
                              "max.height" = "tree h max.",
                              "stem.vol" = "tree vol.",
                              "mean.dbh" = "tree dbh",
                              "vzrumple" = "vert. complex.",
                              "stand.dens" = "tree dens.",
                              "basal.area" = "basal area",
                              "pts.below.2m" = "terr. veg."),
         label_y = case_when(
           metric_label == "tree dens." ~ value + 0.01,
           metric_label == "veg. vol." ~ value + 0.01,
           metric_label == "tree h sd" ~ value + 0.01,
           TRUE ~ value)) %>%
  ggplot(aes(x = scale, y = value, group = metric, color = `75<SA`)) +
  geom_point(size = 3) +
  geom_line() +
  geom_text(data = . %>% filter(scale == "study area"), 
            aes(label = metric_label, y = label_y), 
            hjust = -0.3, 
            size = 3) +
  labs(x = "grid scales", y = "adj. coefficient of variation") +
  theme_minimal() +
  theme(legend.position = "none") +
  scale_x_discrete(labels = c("75 ha" = expression("0.75 km"^2), 
                              "170 ha" = expression("1.7 km"^2), 
                              "650 ha" = expression("6.5 km"^2), 
                              "study area" = expression("study area (26 km"^2*")")))

#ggsave("adjCV_scales.jpg", plot = last_plot(), width = 7.5, height = 6, dpi = 500, device = "jpeg")
```


Again, but using facet wrap
```{r}
#adjusted function
summarize_adj_cv2 <- function(data, scale_column) {
  data %>%
    group_by(!!sym(scale_column)) %>%
    summarize(across(all_of(metric_list_FD), ~ calculate_adj_cv(.x), .names = "adj_cv_{col}")) %>%
    ungroup()
}

#calculate adj CV
adjCV_75ha <- summarize_adj_cv2(stand_mets, "grid75") %>% mutate(scale = "75 ha")
adjCV_170ha <- summarize_adj_cv2(stand_mets, "grid170") %>% mutate(scale = "170 ha")
adjCV_650ha <- summarize_adj_cv2(stand_mets, "grid650") %>% mutate(scale = "650 ha")
adjCV_study_area <- summarize_adj_cv2(stand_mets, "study.area") %>% mutate(scale = "study area")
adjCV_partition <- summarize_adj_cv2(stand_mets, "partition") %>% mutate(scale = "partition")


#combine
adjCV_mets2 <- bind_rows(adjCV_75ha, adjCV_170ha, adjCV_650ha, adjCV_study_area, adjCV_partition)

#prep data for plotting
adjCV_mets_long2 <- adjCV_mets2 %>%
  pivot_longer(cols = starts_with("adj_cv_"), 
               names_to = "metric", 
               values_to = "value", 
               names_prefix = "adj_cv_") %>%
  mutate(metric_label = recode(metric, 
                               "mean.tree.h" = "tree h mean",
                               "zentropy" = "vertical pt. dist.",
                               "lad.max" = "leaf area density",
                               "ClosedGapSpace" = "gap volume",
                               "vFRcanopy" = "veg. vol.",
                               "sd.r" = "tree h sd",
                               "stem.vol" = "tree volume",
                               "mean.dbh" = "tree dbh",
                               "vzrumple" = "vertical pt. complex.",
                               "stand.dens" = "tree density",
                               "basal.area" = "basal area",
                               "pts.below.2m" = "terrestrial veg."))
```

plot
```{r}
#set order
metrics_order2 <- c("tree h mean", "tree h sd", "tree dbh", "basal area", "tree density", "tree volume",
                    "terrestrial veg.", "leaf area density", "gap volume",  
                    "veg. vol.", "vertical pt. dist.", "vertical pt. complex.")

#remove diversity mets, set mets order
adjCV_mets_long2 <- adjCV_mets_long2 %>%
  filter(!metric %in% c("n.all", "shannon_ct", "div_even", "FRich", "FEven", "FDiver")) %>%
  mutate(metric_label = factor(metric_label, levels = metrics_order2))

#set custom titles
custom_titles <- c(
  "tree h mean" = "tree h mean",
  "tree density" = "tree density",
  "tree volume" = "tree volume",
  "terrestrial veg." = "terrestrial veg.",
  "vertical pt. dist." = "vertical pt. dist.",
  "leaf area density" = "leaf area density",
  "veg. vol." = "veg. vol.",
  "vertical pt. complex." = "vertical pt. complex.",
  "gap volume" = "gap volume")

#plot using log scale x axis
adjCV_mets_long2 %>%
  filter(scale != "partition") %>%  # Exclude the partition scale from the main plot
  mutate(scale_numeric = case_when(
    scale == "75 ha" ~ 0.75,
    scale == "170 ha" ~ 1.7,
    scale == "650 ha" ~ 6.5,
    scale == "study area" ~ 26
  )) %>%
  ggplot(aes(x = scale_numeric, y = value, group = metric)) +
  stat_summary(fun = mean, geom = "line", aes(color = "mean trend"), size = 1) +
  stat_summary(data = adjCV_mets_long2 %>% 
                 filter(scale == "partition") %>%
                 mutate(scale_numeric = 1.7), 
               fun = mean, geom = "errorbarh", aes(xmax = 2, xmin = 1.4), 
               color = "forestgreen", size = 1.2, height = 0) +
  facet_wrap(~ metric_label, scales = "free_y",
             labeller = labeller(metric_label = custom_titles), 
             ncol = 3) +
  labs(x = expression("spatial scale ("*km^2*")"), 
       y = "adjusted coefficient of variation") +
  theme_minimal() +
  theme(legend.position = "none") +
  scale_x_log10(breaks = c(0.75, 1.7, 6.5, 26),
                labels = c("0.75", "1.7", "6.5", "26")) +
  scale_color_manual(values = c("mean trend" = "grey30"))

#ggsave("FS_by_scale_line-plot.jpg", plot = last_plot(), width = 7.5, height = 6, dpi = 500, device = "jpeg")
```


Creating species table with observation counts and characteristic data used for calculating FD metrics
```{r}
fd <- read.csv(file = "data/fd_chars.csv", header = TRUE, fileEncoding = "ISO-8859-1")
obsbyft <- read.csv(file = "data/obs_by_ft.csv", header = TRUE)

fd$Species <- fd$Species.name
fd <- fd[, !(names(fd) %in% "Species.name")]

obsbyft <- obsbyft[obsbyft$Species != 'Tupaia longipes (glis)',]


setdiff(fd$Species, obsbyft$Species)
obsbyft$Species[obsbyft$Species == "Family Muridae (unid. rats)"] <- "Family Muridae"
obsbyft$Species[obsbyft$Species == "Family Soricidae (unid. shrews)"] <- "Family Soricidae"

new_table <- left_join(obsbyft[,c("Species", "Total")], fd)

new_table$Activity.Cycle..[new_table$Activity.Cycle.. == 1 & !is.na(new_table$Activity.Cycle..)] <- "nocturnal"
new_table$Activity.Cycle..[new_table$Activity.Cycle.. == 2 & !is.na(new_table$Activity.Cycle..)] <- "crepuscular"
new_table$Activity.Cycle..[new_table$Activity.Cycle.. == 3 & !is.na(new_table$Activity.Cycle..)] <- "diurnal"

new_table$Trophic.Level[new_table$Trophic.Level == 1 & !is.na(new_table$Trophic.Level)] <- "herbivore"
new_table$Trophic.Level[new_table$Trophic.Level == 2 & !is.na(new_table$Trophic.Level)] <- "omnivore"
new_table$Trophic.Level[new_table$Trophic.Level == 3 & !is.na(new_table$Trophic.Level)] <- "carnivore"

#write.csv(new_table, file = "tableS1.csv")
```
