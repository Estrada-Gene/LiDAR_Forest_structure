---
title: "modeling terrestrial and arboreal mammals at GPNP"
author: "Gene Estrada"
date: "2024-05-21"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
	echo = FALSE,
	message = FALSE,
	warning = FALSE)

library(tidyverse)
library(vegan)
library(cowplot)
library(coefplot)
library(PerformanceAnalytics)
library(fitdistrplus)
library(MuMIn)
library(sjPlot)

#mammal observation data - excludes all human observations
m <- read.csv(file = "data/pruned.csv", header = TRUE)
m <- m[,-1]

#adding updated CT location forest type and partition data
ct <- read.csv(file = "data/CTlocations_partitions_May2024.csv", header = TRUE)

#removing lat, long, and habitat designations and adding updated versions
m <- m[,-c(12:14)]
m <- left_join(m, ct[,c("locationID","latitude","longitude","habitat","partition")], by = "locationID")

#ordering forest type
m$habitat <- factor(m$habitat, levels = c("Peat Swamp", "Freshwater Swamp", "Alluvial Bench", 
                                          "Lowland Sandstone", "Lowland Granite", "Upland Granite", "Montane"),
                    ordered = TRUE)
#ordering partitions
m$partition <- factor(m$partition, levels = c("PS1", "FS1", "AB1", "AB2",
                                          "LS1", "LS2","LG1","LG2", "UG1","UG2", "MO1", "MO2"),
                    ordered = TRUE)

#species observation summary table
#species_table <- as.data.frame(table(m$Species, m$habitat))
#species_table <- pivot_wider(species_table, names_from = "Var2", values_from = "Freq")
#colnames(species_table)[colnames(species_table) == 'Var1'] <- 'Species'
#write.csv(species_table, file = "species_observation_table_byFT.csv")

#LiDAR-derived metrics from {FORTLS} and {lidRmetrics}
stand_mets <- read.csv(file = "data/select.stand.mets.csv", header = TRUE)
stand_mets$habitat <- factor(stand_mets$habitat, levels = c("Peat Swamp", "Freshwater Swamp", "Alluvial Bench", 
                                          "Lowland Sandstone", "Lowland Granite", "Upland Granite", "Montane"),
                             ordered = TRUE)
stand_mets$partition <- factor(stand_mets$partition, levels = c("PS1", "FS1", "AB1", "AB2",
                                              "LS1", "LS2","LG1","LG2", "UG1","UG2", "MO1", "MO2"),
                      ordered = TRUE)

#all tree metrics
tree_mets <- read.csv(file = "data/all.tree.mets.csv", header = TRUE)
tree_mets$habitat <- factor(tree_mets$habitat, levels = c("Peat Swamp", "Freshwater Swamp", "Alluvial Bench", 
                                                            "Lowland Sandstone", "Lowland Granite",
                                                          "Upland Granite", "Montane"),
                            ordered = TRUE)
tree_mets$partition <- factor(tree_mets$partition, levels = c("PS1", "FS1", "AB1", "AB2",
                                                                "LS1", "LS2","LG1","LG2", "UG1","UG2", "MO1", "MO2"),
                               ordered = TRUE)
#camera trap data
ct_elev <- read.csv(file = "data/cameradata_updatedZJ-ajm.csv", header = TRUE)
ct_elev <- ct_elev[!duplicated(ct_elev$locationID),]

#add CT survey effort data
ct2 <- read.csv(file = "data/ofp_deployments-2021-11-04.csv", header = TRUE)
ct_active_days <- ct2 %>%
  dplyr::select(Deployment.Location.ID, Camera.Deployment.Begin.Date, Camera.Deployment.End.Date) %>%
  mutate(Camera.Deployment.Begin.Date = as.Date(Camera.Deployment.Begin.Date),
         Camera.Deployment.End.Date   = as.Date(Camera.Deployment.End.Date)) %>%
  mutate(act.per = as.numeric(difftime(Camera.Deployment.End.Date, 
                                       Camera.Deployment.Begin.Date, units = "days"))) %>%
  group_by(Deployment.Location.ID) %>%
  summarise(act.days = sum(act.per)) %>%
  rename(locationID = Deployment.Location.ID)

stand_mets <- left_join(stand_mets, ct_active_days, by = "locationID") 

#adding PanTheria terrestriality data
traits <- read.csv(file = "data/mammal_list_ct_trait_202405.csv", header = TRUE)
m <- left_join(m, traits[,c("Species","Terrestriality")], by = "Species")
```

## SPECIES RICHNESS

### Entire Study Area

Excluding arboreal mammals. all camera trap locations: 40 species. Compared to only CT locations that have LiDAR data: 38 species

```{r}
#all camera trap locations
m %>%
  filter(Terrestriality == 1) %>%
  summarise(SpeciesRichness = n_distinct(Species))

#only camera trap locations that have LiDAR scan data
m %>%
  filter(locationID %in% stand_mets$locationID & Terrestriality == 1) %>%
  summarise(SpeciesRichness = n_distinct(Species))
```

### By forest type

Excluding arboreal mammals

```{r}
#all ct locations
n_by_ft <- m %>%
  group_by(habitat) %>%
  filter(Terrestriality == 1) %>%
  summarise(n.all = n_distinct(Species)) %>%
  arrange(desc(habitat))

#only scanned locations
n_by_ft <- m %>%
  filter(locationID %in% stand_mets$locationID) %>%
  group_by(habitat) %>%
  filter(Terrestriality == 1) %>%
  summarise(n.scanned = n_distinct(Species)) %>%
  left_join(n_by_ft) %>%
  arrange(desc(habitat))

#the scanned sites consistently observe fewer species over the study period by 4 - 10 species
#more bias in the higher elevation FT's, especially the montane
n_by_ft$diff <- n_by_ft$n.all - n_by_ft$n.scanned
n_by_ft
```

### By partition

Excluding unid animals

```{r}
#all ct locations
n_by_pt <- m %>%
  group_by(partition) %>%
  filter(Terrestriality == 1) %>%
  summarise(n.all = n_distinct(Species)) %>%
  arrange(desc(partition))

#only scanned locations
n_by_pt <- m %>%
  filter(locationID %in% stand_mets$locationID) %>%
  group_by(partition) %>%
  filter(Terrestriality == 1) %>%
  summarise(n.scanned = n_distinct(Species)) %>%
  left_join(n_by_pt) %>%
  arrange(desc(partition))

#the scanned sites consistently observe fewer species but this is especially true in UG1 and LS2
n_by_pt$diff <- n_by_pt$n.all - n_by_pt$n.scanned
n_by_pt

```

Again, but for terrestrial mammals only

```{r}
#filtering - unsure if these spp. obs are potentially unique species or not, removing for now
m_filtered <- m %>%
  filter(!Species %in% c("Muntiacus spp.", "Tragulus spp.")) %>% 
  filter(Terrestriality == 1)

#by all partitions
ct_div_mets_terr <- m_filtered %>%
  group_by(partition) %>%
  summarise(n.terr = n_distinct(Species)) %>%
  arrange(desc(partition))

#by aggregated montane partition - combining MO1 and MO2 into one 'partition'
ct_div_mets_terr_mod <- m_filtered %>%
  mutate(partition = case_when(partition %in% c("MO1", "MO2") ~ "MO", TRUE ~ as.character(partition))) %>%
  group_by(partition) %>%
  summarise(n.terr = n_distinct(Species)) %>%
  arrange(desc(partition))
```

### By camera trap location

Excluding arboreal mammals

```{r}
#all CT locations
n_by_ct <- m_filtered %>%
  group_by(locationID) %>%
  summarise(n.all = n_distinct(Species))

#compare 'all CT' and 'scanned CT' location richness distributions
#the 'scanned CT' locations seem biased towards higher species richness
hist(n_by_ct$n.all, breaks = 25,
     main = "species richness - all ct locations", xlab = "n species")
summary(n_by_ct$n.all)

hist(n_by_ct$n.all[n_by_ct$locationID %in% stand_mets$locationID], breaks = 25,
     main = "species richness - scanned ct locations only", xlab = "n species")
summary(n_by_ct$n.all[n_by_ct$locationID %in% stand_mets$locationID])
```

## SHANNON DIVERSITY

### By camera trap location

```{r}
shannon_ct <- diversity(table(m_filtered$locationID, m_filtered$Species), index = "shannon")
shannon_ct <- rownames_to_column(as.data.frame(shannon_ct), var = "locationID")
shannon_ct$locationID <- as.integer(shannon_ct$locationID)

#compare 'all CT' and 'scanned CT' location Shannon Diversity value distributions
#the 'scanned CT' locations seem only slightly biased towards higher diversity values
hist(shannon_ct$shannon_ct, breaks = 25, xlim = c(0,3),
     main = "species diversity - all ct locations", xlab = "Shannon Diversity Index")
summary(shannon_ct$shannon_ct)

hist(shannon_ct$shannon_ct[shannon_ct$locationID %in% stand_mets$locationID], breaks = 25, xlim = c(0,3),
     main = "species diversity - scanned ct locations only", xlab = "Shannon Diversity Index")
summary(shannon_ct$shannon_ct[shannon_ct$locationID %in% stand_mets$locationID])
```

### By partition

Comparing Shannon diversity aggregated at partition for all ct locations to only locations with LiDAR data

```{r}
shannon_all <- diversity(table(m$partition, m$Species), index = "shannon")
shannon_all <- rownames_to_column(as.data.frame(shannon_all), var = "partition")

shannon_scan <- diversity(table(m$partition[shannon_ct$locationID %in% stand_mets$locationID], 
                                m$Species[shannon_ct$locationID %in% stand_mets$locationID]), index = "shannon")
shannon_scan <- rownames_to_column(as.data.frame(shannon_scan), var = "partition")
shannon_pt <- left_join(shannon_all, shannon_scan)
rm(shannon_scan, shannon_all)

shannon_pt$diff <- shannon_pt$shannon_all - shannon_pt$shannon_scan
shannon_pt
```

Creating Shannon diversity metrics for terrestrial mammals only, for all partitions and partitions with montane aggregate

```{r}
### All partitions

#calculating Shannon diversity
shan_terr <- as.data.frame(diversity(table(m_filtered$partition, m_filtered$Species)))
colnames(shan_terr)[1] <- "Shannon"
shan_terr <- rownames_to_column(shan_terr, var = "partition")
ct_div_mets_terr <- left_join(ct_div_mets_terr, shan_terr, by = "partition")
rm(shan_terr)

#aggregated montane
m_filtered_agg <- m_filtered %>%
  mutate(partition = case_when(partition %in% c("MO1", "MO2") ~ "MO", TRUE ~ as.character(partition)))

shan_terr <- as.data.frame(diversity(table(m_filtered_agg$partition, m_filtered_agg$Species)))
colnames(shan_terr)[1] <- "Shannon"
shan_terr <- rownames_to_column(shan_terr, var = "partition")
ct_div_mets_terr_mod <- left_join(ct_div_mets_terr_mod, shan_terr, by = "partition")
rm(shan_terr)
```

### By forest type

```{r}
#calculating shannon diversity index for all and scanned CT locations
shannon_all <- diversity(table(m$habitat, m$Species), index = "shannon")
shannon_all <- rownames_to_column(as.data.frame(shannon_all), var = "habitat")

shannon_scan <- diversity(table(m$habitat[shannon_ct$locationID %in% stand_mets$locationID], 
                m$Species[shannon_ct$locationID %in% stand_mets$locationID]), index = "shannon")
shannon_scan <- rownames_to_column(as.data.frame(shannon_scan), var = "habitat")
shannon_ft <- left_join(shannon_all, shannon_scan)
rm(shannon_scan, shannon_all)

#calculating difference between all and scanned locations shannon index
shannon_ft$diff <- shannon_ft$shannon_all - shannon_ft$shannon_scan
shannon_ft
```

## SPECIES EVENNESS

### By camera trap location

Pielou's diversity measure of species evenness

```{r}
div_mets <- shannon_ct %>%
  left_join(., n_by_ct) %>%
  mutate(div_even = shannon_ct/log(n.all))
div_mets$div_even[div_mets$div_even == "NaN"] <- 0

hist(div_mets$div_even, breaks = 25,
     main = "species evenness", xlab = "Pielou's Evenness Index")
```

### By partition

Pielou's diversity measure of species evenness

```{r}
ct_div_mets_terr$evenness <- ct_div_mets_terr$Shannon / log(ct_div_mets_terr$n.terr)

ct_div_mets_terr_mod$evenness <- ct_div_mets_terr_mod$Shannon / log(ct_div_mets_terr_mod$n.terr)
```

adding diversity metrics to forest structure metrics df

```{r}
stand_mets <- left_join(stand_mets, div_mets[,c("locationID","n.all","shannon_ct","div_even")], 
                        by = "locationID")
stand_mets$div_even <- as.numeric(stand_mets$div_even)
```

## COMMUNITY METRICS VISUALIZATION

#### For terrestrial mammals only

```{r, include=FALSE}
#add habitat data to diversity metrics table
div_mets <- left_join(div_mets, ct[,c("locationID","habitat","partition","altitude")])
div_mets$habitat <- factor(div_mets$habitat, levels = c("Peat Swamp","Freshwater Swamp","Alluvial Bench",
                                                        "Lowland Sandstone","Lowland Granite",
                                                        "Upland Granite","Montane"))
#copying for visualization use only
div_mets$dataset <- "all"
div_mets$dataset[div_mets$locationID %in% stand_mets$locationID] <- "scanned"

div_mets_viz <- div_mets
div_mets_viz_scan <- div_mets_viz[div_mets_viz$dataset == "scanned",]
div_mets_viz$dataset <- "all"
div_mets_viz <- rbind(div_mets_viz, div_mets_viz_scan)
```

### All diversity metrics by CT location/forest type

```{r fig.height=4, fig.width=10}
#plotting richness by all and scanned locations in same plot 
p1 <- ggplot(div_mets_viz, aes(x = habitat, y = n.all, fill = dataset)) +
  geom_boxplot(position = position_dodge(width = 0.75), width = 0.5) +
  geom_jitter(position = position_dodge(width = 0.75)) +
  scale_fill_manual(values = c("cornflowerblue","coral3")) +
  theme_classic() +
  labs(title = "Species Richness", x = "", y = "n species", fill = "") +
  coord_flip() +
  theme(legend.position = "none", plot.title = element_text(hjust = 0.5))

#plotting diversity by all and scanned locations in same plot 
p2 <- ggplot(div_mets_viz, aes(x = habitat, y = shannon_ct, fill = dataset)) +
  geom_boxplot(position = position_dodge(width = 0.75), width = 0.5) +
  geom_jitter(position = position_dodge(width = 0.75)) +
  scale_fill_manual(values = c("cornflowerblue","coral3")) +
  theme_classic() +
  labs(title = "Shannon Diversity", x = "", y = "Shannon Diversity Index", fill = "") +
  coord_flip() +
  theme(legend.position = "none", axis.text.y = element_blank(), 
        plot.title = element_text(hjust = 0.5))

#plotting evenness by all and scanned locations in same plot 
p3 <- ggplot(div_mets_viz, aes(x = habitat, y = div_even, fill = dataset)) +
  geom_boxplot(position = position_dodge(width = 0.75), width = 0.5) +
  geom_jitter(position = position_dodge(width = 0.75)) +
  scale_fill_manual(values = c("cornflowerblue","coral3")) +
  theme_classic() +
  labs(title = "Species Evenness", x = "", y = "Evenness Index", fill = "") +
  coord_flip() +
  guides(fill = guide_legend(reverse = TRUE), color = guide_legend(reverse = TRUE)) +
  theme(legend.position = "none", axis.text.y = element_blank(), 
        plot.title = element_text(hjust = 0.5))

cowplot::plot_grid(p1, p2, p3, nrow = 1, rel_widths = c(.4, .3, .3))
```

### All diversity metrics by elevation

```{r fig.height=4, fig.width=10}
#species richness by elevation - 'all CT locations' and "scanned locations' in the same plot
p1 <- ggplot(div_mets, aes(x = altitude, y = n.all)) +
  geom_point(data = subset(div_mets, locationID %in% stand_mets$locationID), aes(color = "scanned")) +
  geom_point(data = subset(div_mets, !locationID %in% stand_mets$locationID), aes(color = "default")) +
  geom_smooth(data = subset(div_mets, locationID %in% stand_mets$locationID), aes(color = "scanned"), se = TRUE) +
  geom_smooth(data = div_mets, aes(color = "all"), se = TRUE) +  
  scale_color_manual(values = c("scanned" = "red", "all" = "blue", "default" = "black")) +  
  theme_classic() +
  theme(legend.position = "none", plot.title = element_text(hjust = 0.5)) + 
  labs(title = "Species Richness", x = "elevation (m)", y = "n species")

#shannon diversity by elevation
p2 <- ggplot(div_mets, aes(x = altitude, y = shannon_ct)) +
  geom_point(data = subset(div_mets, locationID %in% stand_mets$locationID), aes(color = "scanned")) +
  geom_point(data = subset(div_mets, !locationID %in% stand_mets$locationID), aes(color = "default")) +
  geom_smooth(data = subset(div_mets, locationID %in% stand_mets$locationID), aes(color = "scanned"), se = TRUE) +
  geom_smooth(data = div_mets, aes(color = "all"), se = TRUE) +  
  scale_color_manual(values = c("scanned" = "red", "all" = "blue", "default" = "black")) +  
  theme_classic() +
  theme(legend.position = "none", plot.title = element_text(hjust = 0.5)) + 
  labs(title = "Shannon Diversity", x = "elevation (m)", y = "Shannon Diversity Index")

#species evenness by elevation
p3 <- ggplot(div_mets, aes(x = altitude, y = div_even)) +
  geom_point(data = subset(div_mets, locationID %in% stand_mets$locationID), aes(color = "scanned")) +
  geom_point(data = subset(div_mets, !locationID %in% stand_mets$locationID), aes(color = "default")) +
  geom_smooth(data = subset(div_mets, locationID %in% stand_mets$locationID), aes(color = "scanned"), se = TRUE) +
  geom_smooth(data = div_mets, aes(color = "all"), se = TRUE) +  
  scale_color_manual(values = c("scanned" = "red", "all" = "blue", "default" = "black"),
                     name = NULL,
                     breaks = c("scanned", "all"),
                     labels = c("scanned locations", "all locations")) +  
  theme_classic() +
  theme(legend.position = c(.6, .2), plot.title = element_text(hjust = 0.5)) + 
  labs(title = "Species Evenness", x = "elevation (m)", y = "Species Evenness Index")

cowplot::plot_grid(p1,p2,p3, nrow = 1)
```

## MODELING - Terrestrial mammals (CT data)

```{r}
#scale and center numeric predictors
stand_mets <- stand_mets %>% mutate(across(c(5:16, 22:25, 27:29), scale, .names = "{.col}.sc"))
```

#### Descriptions of forest structure metrics used in models

I used {FORTLS} to extract the following metrics:

1.  max.height - maximum height of trees in the stand, in m

2.  mean.tree.h - mean tree height in the stand, in m.

3.  CRR.rho - canopy relief ratio, using rho for horizontal distance. A measure of canopy variation, with lower scores indicating lower local variation in canopy surface, i.e., more uniform age canopy/ less canopy surface complexity.

4.  sd.r - standard deviation of tree heights in stand in m. I've seen this value used as an approximation for vertical stratification.

5.  mean.dbh - mean diameter at breast height of trees in stand, in cm (measured at height of 1.3m)

6.  basal.area - basal area of trees in the stand (m2/ha)

7.  stand.dens - density of trees in the stand (trees/ha)

8.  stem.vol - volume of trees in the stand (m3/ha)

9.  pts.below.2m - shows the number of points in the point cloud that are below 2m.

I used {lidr} and {lidRmetrics} to extract the following metrics:

10. zentropy - normalized Shannon diversity index of z (height) values. Describes vertical complexity.

11. lad.max - Leaf Area Density maximum value for 1m vertical bins. Describes maximum foliage cover of the point cloud.

12. rumple - Rumple index (rugosity), a ratio of the canopy surface area to it's projected ground area.

vn - number of 1m voxels created for the following volumetric metrics.

13. vFRcanopy - ratio of filled to empty voxels, only counting cells within and below canopy, ignoring above.

14. vzrumple - vertical Rumple index.

15. ClosedGapSpace - volume of voxels that are classified as gaps underneath the canopy


#### Check correlation between predictors. 
Basal area is highly correlated (>0.8) with stem volume and stand density.
```{r}
chart.Correlation(stand_mets[,c("max.height.sc","sd.r.sc","CRR.rho.sc","pts.below.2m.sc","stand.dens.sc",
                                "basal.area.sc","stem.vol.sc","mean.tree.h.sc","mean.dbh.sc", "zentropy.sc",
                                "lad.max.sc","rumple.sc","vFRcanopy.sc","vzrumple.sc","ClosedGapSpace.sc")],
                  method = "spearman")
```


### Models by camera trap location

#### Species richness model

Fitting global model then using {dredge} to find models of best fit.

Top model summary output

```{r}
#fitting global model for use in dredge
rm1 <- glm(n.all ~  
             max.height.sc +
             mean.tree.h.sc +
             CRR.rho.sc +
             sd.r.sc +
             mean.dbh.sc +
             #basal.area.sc + #removing due to cor - model doesn't converge when added
             stand.dens.sc +
             stem.vol.sc +
             pts.below.2m.sc +
             zentropy.sc +
             lad.max.sc +
             rumple.sc +
             vFRcanopy.sc +
             vzrumple.sc +
             ClosedGapSpace.sc,
           na.action = na.fail,
           family = Gamma(link = "log"), 
           offset = log(act.days),
           data = stand_mets)
#dredge
rich_models <- dredge(rm1)

#selecting top model by AIC
top_rich_model <- get.models(rich_models, subset = 1)

summary(top_rich_model[[1]])

plotcoef(top_rich_model[[1]], intercept = FALSE, title = "Terrestrial Mammal Richness - Top Model", ylab = "") +
  theme_classic()
```

averaged model output - averaging top models (delta AIC values < 2)

```{r}
#averaging models with dAIC<2 - this works but I don't know how to plot coefficients
rich_models_avg <- model.avg(rich_models, subset = "delta" < 2)

summary(rich_models_avg)

plot(rich_models_avg, full = NA, intercept = FALSE, main = "Terrestrial Mammal Richness - Averaged Model")
```

#### Species diversity model

Top model summary output
```{r}
#species diversity as outcome variable - by CT location
shannon_model <- glm(shannon_ct ~ 
                         max.height.sc +
                         mean.tree.h.sc +
                         CRR.rho.sc +
                         sd.r.sc +
                         mean.dbh.sc +
                         basal.area.sc +
                         stand.dens.sc +
                         stem.vol.sc +
                         pts.below.2m.sc +
                         zentropy.sc +
                         lad.max.sc +
                         rumple.sc +
                         vFRcanopy.sc +
                         vzrumple.sc +
                         ClosedGapSpace.sc,
                        na.action = na.fail,
                        family = Gamma(link = "log"), 
                        offset = log(act.days),
                        data = stand_mets)

#dredge
shan_models <- dredge(shannon_model)

#selecting top model by AIC
top_shan_model <- get.models(shan_models, subset = 1)

summary(top_shan_model[[1]])

plotcoef(top_shan_model[[1]], intercept = FALSE, title = "Terrestrial Mammal Diversity - Top Model", ylab = "") +
  theme_classic()
```

averaged model output - averaging top models (delta AIC values < 2)
```{r}
#averaging models with dAIC<2
shan_models_avg <- model.avg(shan_models, subset = "delta" < 2)

summary(shan_models_avg)

plot(shan_models_avg, full = NA, intercept = FALSE, main = "Terrestrial Mammal Diversity - Averaged Model")
```

#### Species evenness model

Top model summary output
```{r}
even_model <- glm(div_even ~ 
                max.height.sc +
                mean.tree.h.sc +
                CRR.rho.sc +
                sd.r.sc +
                mean.dbh.sc +
                basal.area.sc +
                stand.dens.sc +
                stem.vol.sc +
                pts.below.2m.sc +
                zentropy.sc +
                lad.max.sc +
                rumple.sc +
                vFRcanopy.sc +
                vzrumple.sc +
                ClosedGapSpace.sc,
                na.action = na.fail,
              family = Gamma(link = "log"), 
              offset = log(act.days),
              data = stand_mets)
#dredge
even_models <- dredge(even_model)

#selecting top model by AIC
top_even_model <- get.models(even_models, subset = 1)

summary(top_even_model[[1]])

plotcoef(top_even_model[[1]], intercept = FALSE, title = "Terrestrial Mammal Evenness - Top Model", ylab = "") +
  theme_classic()
```

averaged model output - averaging top models (delta AIC values < 2)

```{r}
#averaging models with dAIC<2
even_models_avg <- model.avg(even_models, subset = "delta" < 2)

summary(even_models_avg)

plot(even_models_avg, full = NA, intercept = FALSE, main = "Terrestrial Mammal Evenness - Avg. Model")
```

comparing coefficient plot from the three top models

```{r}
multiplot(top_rich_model[[1]], top_shan_model[[1]], top_even_model[[1]], intercept = FALSE, 
          decreasing = TRUE, names = c("richness","diversity","evenness")) + 
  labs(title = "Terrestrial Mammal Community Models", subtitle = "camera trap obs.", x = "coefficient", y = "") +
  theme_classic() +
  theme(legend.position = "bottom", legend.box = "horizontal")
  #+ scale_y_discrete(labels = rev(c("tree dens.","leaf area dens.","vert. complexity",
                            #"gap vol.","max. tree h","veg. vol.","vert. rumple")))
```

summary table comparing the three top models

```{r}
tab_model(top_rich_model[[1]], top_shan_model[[1]], top_even_model[[1]], transform = NULL,
          dv.labels = c("Species Richness","Shannon Diversity","Species Evenness")
          #, file = "table1.xls"   #export as Excel file for manuscript submission
          )
```


### Models by partition

```{r include=FALSE}
#calculating mean of all scaled predictors aggregated by partition
pt_mets <- stand_mets %>%
  group_by(partition) %>%
  dplyr::select(ends_with(".sc")) %>%
  summarize(across(where(is.numeric), mean, na.rm = TRUE))  # I could add the StdDev of variables of interest too

ct_div_mets_terr <- left_join(ct_div_mets_terr, pt_mets)

#adding ct effort days
ct_div_mets_terr <- ct %>%
  left_join(ct_active_days) %>%
  group_by(partition) %>%
  summarise(effort = sum(act.days, na.rm = TRUE)) %>%
  filter(!partition == "Kerangas") %>%
  left_join(ct_div_mets_terr)
```

#### Species richness model

Fitting global model then using {dredge} to find models of best fit.

Top model summary output. I have to adjust which predictors are included, since I can only have up to 8 predictors for a model with 11 data points in the outcome variable. After adjusting predictors, the top avg. model continues to show vFRcanopy (postive) and rumple (pos) as reliable predictors.
```{r}
#removing MO1 partition since no structure mets are from this pt
ct_div_mets_terr <- ct_div_mets_terr[!ct_div_mets_terr$partition == "MO1",]
```

```{r}
#fitting global model for use in dredge
rm_pt1 <- glm(n.terr ~ 
             max.height.sc +
             #mean.tree.h.sc +
             #CRR.rho.sc +
             #sd.r.sc +
             #mean.dbh.sc +
             #basal.area.sc + 
             #stand.dens.sc +
             #stem.vol.sc +
             pts.below.2m.sc +
             zentropy.sc +
             lad.max.sc +
             rumple.sc +
             vFRcanopy.sc +
             vzrumple.sc +
             ClosedGapSpace.sc,
           na.action = na.fail,
           family = Gamma(link = "log"), 
           offset = log(effort),
           data = ct_div_mets_terr)
#dredge
rich_pt_models <- dredge(rm_pt1)

#selecting top model by AIC
top_rich_pt_model <- get.models(rich_pt_models, subset = 1)

summary(top_rich_pt_model[[1]])

plotcoef(top_rich_pt_model[[1]], intercept = FALSE, title = "Terrestrial Mammal Richness (partition) - Top Mod", ylab = "") +
  theme_classic()
```

averaged model output - averaging top models (delta AIC values \< 2)
when I expand the dAIC values to <5 zentropy is included and is the strongest (pos) predictor
```{r}
#averaging models with dAIC<2
rich_models_pt_avg <- model.avg(rich_pt_models, subset = "delta" < 2)

summary(rich_models_pt_avg)

plot(rich_models_pt_avg, full = NA, intercept = FALSE, main = "Terrestrial Mammal Richness (partition) - Av. Mod")
```

#### Species diversity model

Fitting global model then using {dredge} to find models of best fit.

Top model summary output. After adjusting predictors, the top avg. model continues to show vFRcanopy, rumple, zentropy, and mean dbh as reliable positive predictors.

```{r}
#global model
sm_pt1 <- glm(Shannon ~  
             #max.height.sc +
             #mean.tree.h.sc +
             #CRR.rho.sc +
             #sd.r.sc +
             mean.dbh.sc +
             #basal.area.sc + 
             #stand.dens.sc +
             stem.vol.sc +
             pts.below.2m.sc +
             zentropy.sc +
             lad.max.sc +
             rumple.sc +
             vFRcanopy.sc +
             vzrumple.sc,
             #ClosedGapSpace.sc,
           na.action = na.fail,
           family = Gamma(link = "log"), 
           offset = log(effort),
           data = ct_div_mets_terr)
#dredge
shan_pt_models <- dredge(sm_pt1)

#selecting top model by AIC
top_shan_pt_model <- get.models(shan_pt_models, subset = 1)

summary(top_shan_pt_model[[1]])

plotcoef(top_shan_pt_model[[1]], intercept = FALSE, title = "Terrestrial Mammal Diversity (partition) - Top Mod", ylab = "") +
  theme_classic()
```

averaged model output - averaging top models (delta AIC values \< 2)

```{r}
#averaging models with dAIC<2 - this works but I don't know how to plot coefficients
shan_models_pt_avg <- model.avg(shan_pt_models, subset = "delta" < 2)

summary(shan_models_pt_avg)

plot(shan_models_pt_avg, full = NA, intercept = FALSE, main = "Terrestrial Mammal Diversity (partition) - Av. Mod")
```

#### Species evenness model

Top model summary output. After adjusting predictors, the top avg. model continues to show vFRcanopy, rumple, zentropy, and mean dbh as reliable positive predictors.

```{r}
#global model
em_pt1 <- glm(evenness ~  
             max.height.sc +
             #mean.tree.h.sc +
             #CRR.rho.sc +
             #sd.r.sc +
             mean.dbh.sc +
             #basal.area.sc + 
             #stand.dens.sc +
             #stem.vol.sc +
             pts.below.2m.sc +
             zentropy.sc +
             lad.max.sc +
             rumple.sc +
             vFRcanopy.sc +
             vzrumple.sc,
             #ClosedGapSpace.sc,
           na.action = na.fail,
           family = Gamma(link = "log"), 
           offset = log(effort),
           data = ct_div_mets_terr)
#dredge
even_pt_models <- dredge(em_pt1)

#selecting top model by AIC
top_even_pt_model <- get.models(even_pt_models, subset = 1)

summary(top_even_pt_model[[1]])

plotcoef(top_even_pt_model[[1]], intercept = FALSE, title = "Terrestrial Mammal Evenness (partition) - Top Mod", ylab = "") +
  theme_classic()
```

averaged model output - averaging top models (delta AIC values \< 2)

```{r}
#averaging models with dAIC<2 - this works but I don't know how to plot coefficients
even_models_pt_avg <- model.avg(even_pt_models, subset = "delta" < 6)

summary(even_models_pt_avg)

plot(even_models_pt_avg, full = NA, intercept = FALSE, main = "Terrestrial Mammal Evenness (partition) - Av. Mod")
```

## MODELING - Arboreal mammals (census data)